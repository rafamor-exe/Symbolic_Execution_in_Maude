load smt.maude

view Real from TRIV to REAL is
  sort Elt to Real .
endv

fmod WHILE-LANG-VARSTATE-MOD is

    pr REAL-INTEGER .
    pr BOOLEAN .

    sort AExp .
    sort Value .
    sorts RVal BVal IVal .
    subsort IVal RVal < Value < AExp .

    op val : Real -> RVal [ctor] .
    op val : Integer -> IVal [ctor] .
    op val : Boolean -> BVal [ctor] .

    vars V V1 V2 : Value .
    vars R R1 R2 : Real .
    var B : Boolean .
    vars I I1 I2 : Integer .

    op _+_ : Value Value -> Value [gather (E e) prec 33] .
    eq val(R1) + val(R2) = val(R1 + R2) .
    eq val(I1) + val(I2) = val(I1 + I2) .
    op _*_ : Value Value -> Value [gather (E e) prec 31] .
    eq val(R1) * val(R2) = val(R1 * R2) .
    eq val(I1) * val(I2) = val(I1 * I2) .
    op _-_ : Value Value -> Value [gather (E e) prec 33] .
    eq val(R1) - val(R2) = val(R1 - R2) .
    eq val(I1) - val(I2) = val(I1 - I2) .
    op _/_ : Value Value -> Value [gather (E e) prec 31] .
    eq val(R1) / val(R2) = val(R1 / R2) .
    eq val(I1) / val(I2) = val(I1 div I2) .

    op _===_ : Value Value -> Boolean [gather (e E) prec 51] .
    eq V1 === V1 = true .
    eq V1 === V2 = false [owise] .
    op _=/==_ : Value Value -> Boolean [gather (e E) prec 51] .
    eq V1 =/== V1 = false .
    eq V1 =/== V2 = true [owise] .
    op _<_ : Value Value -> Boolean [prec 37] .
    eq val(R1) < val(R2) = R1 < R2 .
    eq val(I1) < val(I2) = I1 < I2 .
    op _<=_ : Value Value -> Boolean [prec 37] .
    eq val(R1) <= val(R2) = R1 <= R2 .
    eq val(I1) <= val(I2) = I1 <= I2 .
    op _>_ : Value Value -> Boolean [prec 37] .
    eq val(R1) > val(R2) = R1 > R2 .
    eq val(I1) > val(I2) = I1 > I2 .
    op _>=_ : Value Value -> Boolean [prec 37] .
    eq val(R1) >= val(R2) = R1 >= R2 .
    eq val(I1) >= val(I2) = I1 >= I2 .

endfm

view Value from TRIV to WHILE-LANG-VARSTATE-MOD is
  sort Elt to Value .
endv

fmod WHILE-LANG-VAR-MOD is

    pr QID .
    pr WHILE-LANG-VARSTATE-MOD .

    sort Var .
    subsort Var < AExp .

    op var : Qid -> Var [ctor] .

endfm

view Var from TRIV to WHILE-LANG-VAR-MOD is
  sort Elt to Var .
endv

fmod WHILE-LANG-AEXP-MOD is

    pr WHILE-LANG-VAR-MOD .
    pr MAP{Var, Value} .

    sort BExp .
    subsort Boolean < BExp .

    op _+_ : AExp AExp -> AExp [gather (E e) prec 33] .
    op _*_ : AExp AExp -> AExp [gather (E e) prec 31] .
    op _-_ : AExp AExp -> AExp [gather (E e) prec 33] .
    op _/_ : AExp AExp -> AExp [gather (E e) prec 31] .

    op _=_ : AExp AExp -> BExp [gather (e E) prec 51] .
    op _!=_ : AExp AExp -> BExp [gather (e E) prec 51] .
    op _<_ : AExp AExp -> BExp [prec 37] .
    op _<=_ : AExp AExp -> BExp [prec 37] .
    op _>_ : AExp AExp -> BExp [prec 37] .
    op _>=_ : AExp AExp -> BExp [prec 37] .
    op _/\_ : BExp BExp -> BExp [ctor assoc] .
    op not_ : BExp -> BExp [ditto] .

    op eval : BExp -> Boolean .
    op eval : AExp Map{Var, Value} -> Value .
    op eval : BExp Map{Var, Value} -> BExp .
    op eval : BVal Map{Var, Value} -> BExp .
    op eval : Boolean Map{Var, Value} -> BExp .

    vars AExp AExp1 AExp2 : AExp .
    vars B BExp1 BExp2 : Boolean .
    var BExp : BExp .
    var STR : Map{Var, Value} .
    var Var : Var .
    var V : Value .

    eq eval(AExp1 + AExp2, STR) = eval(AExp1, STR) + eval(AExp2, STR) .
    eq eval(AExp1 * AExp2, STR) = eval(AExp1, STR) * eval(AExp2, STR) .
    eq eval(AExp1 - AExp2, STR) = eval(AExp1, STR) - eval(AExp2, STR) .
    eq eval(AExp1 / AExp2, STR) = eval(AExp1, STR) / eval(AExp2, STR) .
    eq eval(AExp1 = AExp2, STR) = eval(AExp1, STR) === eval(AExp2, STR) .
    eq eval(AExp1 != AExp2, STR) = eval(AExp1, STR) =/== eval(AExp2, STR) .
    eq eval(AExp1 < AExp2, STR) = eval(AExp1, STR) < eval(AExp2, STR) .
    eq eval(AExp1 <= AExp2, STR) = eval(AExp1, STR) <= eval(AExp2, STR) .
    eq eval(AExp1 > AExp2, STR) = eval(AExp1, STR) > eval(AExp2, STR) .
    eq eval(AExp1 >= AExp2, STR) = eval(AExp1, STR) >= eval(AExp2, STR) .
    eq eval(BExp1 /\ BExp, STR) = eval(BExp1, STR) and eval(BExp, STR) .
    eq eval(not BExp1, STR) = not eval(BExp1, STR) .
    eq eval(Var, ((Var |-> V), STR)) = V .
    eq eval(V, STR) = V .
    eq eval(B, STR) = B .

    eq not not BExp = BExp .

endfm

fmod WHILE-LANG-INSTS-MOD is

    pr WHILE-LANG-AEXP-MOD .

    sort Inst .

    op skip ; : -> Inst [ctor prec 20] .
    op _ := _ ; : Var AExp -> Inst [ctor prec 20] .

endfm

view Inst from TRIV to WHILE-LANG-INSTS-MOD is
  sort Elt to Inst .
endv

fmod WHILE-LANG-BLOCK-MOD is

    pr WHILE-LANG-INSTS-MOD .
    pr LIST{Inst} * (sort List{Inst} to Program) .

    op if _ then {_} else {_} : BExp Program Program -> Inst [ctor prec 20] .
    op if _ then {_} : BExp Program -> Inst [prec 20] .

    op while _ do {_} : BExp Program -> Inst [ctor prec 20] .

    var B : BExp .
    var IL1 : Program .

    eq if B then {IL1} = if B then {IL1} else {nil} .

endfm

fmod WHILE-BASICS is
    pr WHILE-LANG-BLOCK-MOD .
endfm

fmod WHILE-LANG-SE-LOCS-MOD is
    pr QID .
    sort Location .
    ops skip assign if1 if2 while1 while2 : -> Location [ctor] .
    op loc : Qid -> Location [ctor] .
endfm

view Location from TRIV to WHILE-LANG-SE-LOCS-MOD is
  sort Elt to Location .
endv

fmod WHILE-SE-BASICS is
    pr WHILE-LANG-BLOCK-MOD .
    pr WHILE-LANG-SE-LOCS-MOD .
    pr LIST{Location} * (sort List{Location} to Path) .
endfm