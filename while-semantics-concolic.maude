load smt.maude
load smt-conversion.maude
load while-semantics-basics.maude

fmod SMT-CONNECTION is
    pr WHILE-LANG-AEXP-MOD .

    sort Assignment .

    op _<--_ : Real Real -> Assignment [ctor] . *** test syntax
    op _<--_ : Integer Integer -> Assignment [ctor] . *** test syntax
    op _,_ : Assignment Assignment -> Assignment .
    op failed : -> Assignment [ctor] .

    op get-SMTassignment : Boolean -> Assignment [special (id-hook SpecialHubSymbol)] .

endfm

mod WHILE-MAUDE is

    pr WHILE-SE-BASICS .
    pr LIST{Location} * (sort List{Location} to Path) .
    pr INT .
    pr META-LEVEL * (op _=_ to _=M_) * (op _+_ to _+M_) .
    pr SMT-CONNECTION .

    sorts SEState PState ConcolicState ConcolicStateCore .
    sort ConstrainedStart .
    sorts CThread MTExec .
    subsort CThread Program < MTExec .

    op _ [_] : Program Nat -> CThread [ctor] .
    op noProgram : -> MTExec [ctor] .
    op _ || _ : MTExec MTExec -> MTExec [ctor assoc comm id: noProgram] .


    op < _ | _ > : MTExec Map{Var, Value} -> PState [ctor] . 
    op errState : -> PState [ctor] .

    op _ {_} < {_} : PState BExp Path -> SEState [ctor] . 

    op _ where _ : MTExec BExp -> ConstrainedStart [ctor] .

    op [_] [_] [_] : PState SEState Int -> ConcolicStateCore [ctor] .
    op _ [_] [_/_] : ConcolicStateCore Map{Var, Value} Nat Bound -> ConcolicState [ctor] .




    vars Var : Var .
    vars BExp BExp2 Constraints Constraints' : BExp .
    vars B Constraint C1 : Boolean .
    vars R Rconc : Real .
    vars I Iconc : Integer .
    vars IL IL1 IL2 : Program .
    vars STR STR' SymbSTR STRInit : Map{Var, Value} .
    var AExp : AExp .
    var Path : Path .
    var SVDeclL : Program .
    var V : Value .
    vars SEPState CEPState : PState .
    var N : Nat .
    var Assignment : Assignment .
    var LBound : Bound .
    var LDepth : Nat .
    vars P PRest : MTExec .

    op start : MTExec -> ConcolicState .
    op start : ConstrainedStart -> ConcolicState .
    eq start(P) = $start(P, nil, empty, true, unbounded) .
    eq start(P where BExp) = $start(P, nil, empty, BExp, unbounded) .
    op start : MTExec Program -> ConcolicState .
    op start : ConstrainedStart Program -> ConcolicState .
    op start : MTExec Program Bound -> ConcolicState .
    op start : ConstrainedStart Program Bound -> ConcolicState .
    eq start(P, SVDeclL) = $start(P, SVDeclL, empty, true, unbounded) .
    eq start(P where BExp, SVDeclL) = $start(P, SVDeclL, empty, BExp, unbounded) .
    eq start(P, SVDeclL, LBound) = $start(P, SVDeclL, empty, true, LBound) .
    eq start(P where BExp, SVDeclL, LBound) = $start(P, SVDeclL, empty, BExp, LBound) .
    op $start : MTExec Program Map{Var, Value} BExp Bound -> ConcolicState .
    eq $start(P, nil, STR, BExp, LBound) = [ < P | init-CStore(STR, BExp) > ] [ < P | STR > {BExp} < {nil} ] [size(BExp)] [STR] [0 / LBound] . *** Don't negate initial conditions, only path conditions
    eq $start(P, (Var := V ;) SVDeclL, STR, BExp, LBound) = $start(P, SVDeclL, insert(Var, V, STR), BExp, LBound) .

    rl [C-skip] : 
        [ < skip ; IL || PRest | STR > ] [ SEPState {Constraints} < {Path} ] [N]
        =>
        [ < IL || PRest | STR > ] [ SEPState {Constraints} < {Path skip} ] [N] .

    rl [C-assign] : 
        [ < Var := AExp ; IL || PRest | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N]
        =>
        [ < IL || PRest | insert(Var, eval(AExp, STR), STR) > ] [ < P | insert(Var, eval(AExp, SymbSTR), SymbSTR) > {Constraints} < {Path assign} ] [N] .

    crl [C-if..then] :
        [ < if BExp then { IL1 } else { IL2 } IL || PRest | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N]
        =>
        [ < IL1 IL || PRest | STR > ] [ < P | SymbSTR > {Constraints'} < {Path if1} ] [N]
        if Constraints' := (Constraints /\ eval(BExp, SymbSTR))
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) === (true).Boolean)) .
    
    crl [C-if..else-spawn] :
        [ < if BExp then { IL1 } else { IL2 } IL || PRest | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N] [STRInit] [LDepth / LBound]
        =>
        [ < P | init-CStore(STRInit, eval(Constraints', STR)) > ] [ < P | STRInit > {Constraints'} < {nil} ] [N + 1] [STRInit] [0 / LBound]
        if metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) === (true).Boolean))
        /\ Constraints' := (Constraints /\ (not eval(BExp, SymbSTR)))
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(Constraints', STR))) .

    crl [C-if..else] :
        [ < if BExp then { IL1 } else { IL2 } IL || PRest | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N]
        =>
        [ < IL2 IL || PRest | STR > ] [ < P | SymbSTR > {Constraints'} < {Path if2} ] [N]
        if Constraints' := (Constraints /\ (not eval(BExp, SymbSTR))) 
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) =/== (true).Boolean)) .
    
    crl [C-if..then-spawn] :
        [ < if BExp then { IL1 } else { IL2 } IL || PRest | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N] [STRInit] [LDepth / LBound]
        =>
        [ < P | init-CStore(STRInit, eval(Constraints', STR)) > ] [ < P | STRInit > {Constraints'} < {nil} ] [N + 1] [STRInit] [0 / LBound]
        if metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) =/== (true).Boolean))
        /\ Constraints' := (Constraints /\ eval(BExp, SymbSTR))
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(Constraints', STR))) .
    

    crl [C-while..loop] : 
        [ < while BExp do { IL1 } IL || PRest | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N] [STRInit] [LDepth / LBound]
        =>
        [ < IL1 while BExp do { IL1 } IL || PRest | STR > ] [ < P | SymbSTR > {Constraints'} < {Path while1} ] [N] [STRInit] [LDepth / LBound]
        if Constraints' := (Constraints /\ eval(BExp, SymbSTR))
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) === (true).Boolean)) .
    
    crl [C-while..exit-spawn] : 
        [ < while BExp do { IL1 } IL || PRest | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N] [STRInit] [LDepth / LBound]
        =>
        [ < P | init-CStore(STRInit, eval(Constraints', STR)) > ] [ < P | STRInit > {Constraints'} < {nil} ] [N + 1] [STRInit] [LDepth / LBound]
        if metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) === (true).Boolean))
        /\ Constraints' := (Constraints /\ (not eval(BExp, SymbSTR)))
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(Constraints', STR))) .
        
    crl [C-while..exit] : 
        [ < while BExp do { IL1 } IL || PRest | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N] [STRInit] [LDepth / LBound]
        =>
        [ < IL || PRest | STR > ] [ < P | SymbSTR > {Constraints'} < {Path while2} ] [N] [STRInit] [0 / LBound]
        if Constraints' := (Constraints /\ (not eval(BExp, SymbSTR))) 
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) =/== (true).Boolean)) .
    
    crl [C-while..loop-spawn] : 
        [ < while BExp do { IL1 } IL || PRest | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N] [STRInit] [LDepth / LBound]
        =>
        [ < P | init-CStore(STRInit, eval(Constraints', STR)) > ] [ < P | STRInit > {Constraints'} < {nil} ] [N + 1] [STRInit] [LDepth + 1 / LBound]
        if metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) =/== (true).Boolean))
        /\ Constraints' := (Constraints /\ eval(BExp, SymbSTR))
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(Constraints', STR)))
        /\ withinBounds(LDepth, LBound) .
    
    op withinBounds : Nat Bound -> Bool .
    eq withinBounds(LDepth, unbounded) = true .
    ceq withinBounds(LDepth, LBound) = true if LDepth < LBound .
    eq withinBounds(LDepth, LBound) = false [owise] .

    op init-CStore : Map{Var, Value} BExp -> Map{Var, Value} .
    ceq init-CStore(STR, Constraints) = $apply-SMTassignment(STR, get-SMTassignment(C1))
        if C1 := eval(Constraints, STR) .

    op $apply-SMTassignment : Map{Var, Value} Assignment -> Map{Var, Value} .
    eq $apply-SMTassignment((Var |-> val(R), STR), R <-- Rconc) = (Var |-> val(Rconc), STR) .
    eq $apply-SMTassignment((Var |-> val(R), STR), R <-- Rconc ; Assignment) = (Var |-> val(Rconc), $apply-SMTassignment(STR, Assignment)) .
    eq $apply-SMTassignment((Var |-> val(I), STR), I <-- Iconc) = (Var |-> val(Iconc), STR) .
    eq $apply-SMTassignment((Var |-> val(I), STR), I <-- Iconc ; Assignment) = (Var |-> val(Iconc), $apply-SMTassignment(STR, Assignment)) .
    eq $apply-SMTassignment(STR, failed) = STR .

    op size : BExp -> Nat .
    eq size(C1) = 1 .
    eq size ((C1 /\ Constraints)) = 1 + size(Constraints) .

endm