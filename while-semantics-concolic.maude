load smt.maude
load smt-conversion.maude
***set trace on .

view Real from TRIV to REAL is
  sort Elt to Real .
endv

fmod WHILE-LANG-VARSTATE-MOD is

    pr REAL-INTEGER .
    pr BOOLEAN .

    sort AExp .
    sort VarState .
    sorts VarType Value .
    sorts RVal BVal IVal .
    subsort IVal RVal < Value < AExp .
    ***subsort Real < AExp .
    ***subsort Boolean BVal < SimpleBExp .

    ops boolean real : -> VarType [ctor] .

    op val : Real -> RVal [ctor] .
    op val : Integer -> IVal [ctor] .
    op val : Boolean -> BVal [ctor] .

    op {type _, val _} : VarType Value -> VarState [ctor] .

    var T : VarType .
    var V V1 V2 : Value .
    var R R1 R2 : Real .
    var B : Boolean .
    var I I1 I2 : Integer .

    op getType : VarState -> VarType .
    eq getType({type T, val V}) = T .

    op getVal : VarState -> Value .
    eq getVal({type T, val V}) = V .

    op _+_ : Value Value -> Value [gather (E e) prec 33] .
    eq val(R1) + val(R2) = val(R1 + R2) .
    eq val(I1) + val(I2) = val(I1 + I2) .
    op _*_ : Value Value -> Value [gather (E e) prec 31] .
    eq val(R1) * val(R2) = val(R1 * R2) .
    eq val(I1) * val(I2) = val(I1 * I2) .
    op _-_ : Value Value -> Value [gather (E e) prec 33] .
    eq val(R1) - val(R2) = val(R1 - R2) .
    eq val(I1) - val(I2) = val(I1 - I2) .
    op _/_ : Value Value -> Value [gather (E e) prec 31] .
    eq val(R1) / val(R2) = val(R1 / R2) .
    eq val(I1) / val(I2) = val(I1 div I2) .

    op _===_ : Value Value -> Boolean [gather (e E) prec 51] .
    eq V1 === V1 = true .
    eq V1 === V2 = false [owise] .
    op _=/==_ : Value Value -> Boolean [gather (e E) prec 51] .
    eq V1 =/== V1 = false .
    eq V1 =/== V2 = true [owise] .
    op _<_ : Value Value -> Boolean [prec 37] .
    eq val(R1) < val(R2) = R1 < R2 .
    eq val(I1) < val(I2) = I1 < I2 .
    op _<=_ : Value Value -> Boolean [prec 37] .
    eq val(R1) <= val(R2) = R1 <= R2 .
    eq val(I1) <= val(I2) = I1 <= I2 .
    op _>_ : Value Value -> Boolean [prec 37] .
    eq val(R1) > val(R2) = R1 > R2 .
    eq val(I1) > val(I2) = I1 > I2 .
    op _>=_ : Value Value -> Boolean [prec 37] .
    eq val(R1) >= val(R2) = R1 >= R2 .
    eq val(I1) >= val(I2) = I1 >= I2 .

endfm

view VarState from TRIV to WHILE-LANG-VARSTATE-MOD is
  sort Elt to VarState .
endv

view Value from TRIV to WHILE-LANG-VARSTATE-MOD is
  sort Elt to Value .
endv

fmod WHILE-LANG-VAR-MOD is

    pr QID .
    pr WHILE-LANG-VARSTATE-MOD .

    sort Var .
    subsort Var < AExp .

    op var : Qid -> Var [ctor] .

endfm

view Var from TRIV to WHILE-LANG-VAR-MOD is
  sort Elt to Var .
endv

fmod WHILE-LANG-AEXP-MOD is

    pr WHILE-LANG-VAR-MOD .
    pr MAP{Var, Value} .

    sort BExp .
    subsort Boolean < BExp .

    op _+_ : AExp AExp -> AExp [gather (E e) prec 33] .
    op _*_ : AExp AExp -> AExp [gather (E e) prec 31] .
    op _-_ : AExp AExp -> AExp [gather (E e) prec 33] .
    op _/_ : AExp AExp -> AExp [gather (E e) prec 31] .

    op _=_ : AExp AExp -> Boolean [gather (e E) prec 51] .
    op _!=_ : AExp AExp -> Boolean [gather (e E) prec 51] .
    op _<_ : AExp AExp -> Boolean [prec 37] .
    op _<=_ : AExp AExp -> Boolean [prec 37] .
    op _>_ : AExp AExp -> Boolean [prec 37] .
    op _>=_ : AExp AExp -> Boolean [prec 37] .
    op _/\_ : BExp BExp -> BExp [ctor assoc] .
    op not_ : BExp -> Boolean [ditto] .

    op eval : BExp -> Boolean .
    op eval : AExp Map{Var, Value} -> Value .
    op eval : BExp Map{Var, Value} -> Boolean .
    op eval : BVal Map{Var, Value} -> Boolean .
    op eval : Boolean Map{Var, Value} -> Boolean .

    var R R1 R2 : Real .
    var I I1 I2 : Real .
    var AExp AExp1 AExp2 : AExp .
    var B BExp1 BExp2 : Boolean .
    var BExp : BExp .
    var STR : Map{Var, Value} .
    var Var : Var .
    var V V1 V2 : Value .

    eq eval(AExp1 + AExp2, STR) = eval(AExp1, STR) + eval(AExp2, STR) .
    eq eval(AExp1 * AExp2, STR) = eval(AExp1, STR) * eval(AExp2, STR) .
    eq eval(AExp1 - AExp2, STR) = eval(AExp1, STR) - eval(AExp2, STR) .
    eq eval(AExp1 / AExp2, STR) = eval(AExp1, STR) / eval(AExp2, STR) .
    eq eval(AExp1 = AExp2, STR) = eval(AExp1, STR) === eval(AExp2, STR) .
    eq eval(AExp1 != AExp2, STR) = eval(AExp1, STR) =/== eval(AExp2, STR) .
    eq eval(AExp1 < AExp2, STR) = eval(AExp1, STR) < eval(AExp2, STR) .
    eq eval(AExp1 <= AExp2, STR) = eval(AExp1, STR) <= eval(AExp2, STR) .
    eq eval(AExp1 > AExp2, STR) = eval(AExp1, STR) > eval(AExp2, STR) .
    eq eval(AExp1 >= AExp2, STR) = eval(AExp1, STR) >= eval(AExp2, STR) .
    eq eval(BExp1 /\ BExp, STR) = eval(BExp1, STR) and eval(BExp, STR) .
    eq eval(not BExp1, STR) = not eval(BExp1, STR) .
    ***eq eval(Var, (Var |-> R)) = R .
    eq eval(Var, ((Var |-> V), STR)) = V .
    eq eval(V, STR) = V .
    ***eq eval(val(B), STR) = B .
    ***eq eval(R, STR) = R .
    eq eval(B, STR) = B .

    eq not not BExp = BExp .

endfm

fmod WHILE-LANG-INSTS-MOD is

    pr WHILE-LANG-AEXP-MOD .

    sort Inst .

    op skip ; : -> Inst [ctor prec 20] .
    op _ := _ ; : Var AExp -> Inst [ctor prec 20] .

endfm

view Inst from TRIV to WHILE-LANG-INSTS-MOD is
  sort Elt to Inst .
endv

fmod WHILE-LANG-BLOCK-MOD is

    pr WHILE-LANG-INSTS-MOD .
    pr LIST{Inst} * (sort List{Inst} to Program) .

    op if _ then {_} else {_} : BExp Program Program -> Inst [ctor prec 20] .
    op if _ then {_} : BExp Program -> Inst [prec 20] .

    op while _ do {_} : BExp Program -> Inst [ctor prec 20] .

    var B : BExp .
    var IL1 : Program .

    eq if B then {IL1} = if B then {IL1} else {nil} .

endfm

fmod WHILE-LANG-SE-LOCS-MOD is
    sort Location .
    ops skip assign if1 if2 while1 while2 while-inv assume : -> Location [ctor] .
endfm

view Location from TRIV to WHILE-LANG-SE-LOCS-MOD is
  sort Elt to Location .
endv

fmod SMT-CONNECTION is
    pr WHILE-LANG-AEXP-MOD .

    sort Assignment .

    op _<--_ : Real Real -> Assignment [ctor] . *** test syntax
    op _<--_ : Integer Integer -> Assignment [ctor] . *** test syntax
    op _,_ : Assignment Assignment -> Assignment .
    op failed : -> Assignment [ctor] .

    op get-SMTassignment : Boolean -> Assignment [special (id-hook SpecialHubSymbol)] .

endfm

mod WHILE-MAUDE is

    pr WHILE-LANG-BLOCK-MOD .
    pr WHILE-LANG-SE-LOCS-MOD .
    pr LIST{Location} * (sort List{Location} to Path) .
    pr INT .
    pr META-LEVEL * (op _=_ to _=M_) * (op _+_ to _+M_) .
    pr SMT-CONNECTION .

    sorts SEState PState ConcolicState ConcolicStateCore .
    sort ConstrainedStart .
    
    op < _ | _ > : Program Map{Var, Value} -> PState [ctor] . 
    op errState : -> PState [ctor] .

    op _ {_} < {_} : PState BExp Path -> SEState [ctor] . 

    op _ where _ : Program BExp -> ConstrainedStart [ctor] .

    op [_] [_] [_] : PState SEState Int -> ConcolicStateCore [ctor] .
    op _ [_] [_/_] : ConcolicStateCore Map{Var, Value} Nat Bound -> ConcolicState [ctor] .


    vars Var Var1 Var2 : Var .
    var B : Boolean .
    vars BExp BExp2 Constraints Constraints' : BExp .
    vars Constraint C1 : Boolean .
    var RealVal R Rconc : Real .
    var I Iconc : Integer .
    vars P IL IL1 IL2 : Program .
    vars STR STR' SymbSTR STRInit : Map{Var, Value} .
    var VarState : VarState .
    var AExp : AExp .
    var Path : Path .
    var SVDeclL : Program .
    var V : Value .
    vars SEPState CEPState : PState .
    var N : Int .
    var NzN : NzNat .
    var Assignment : Assignment .
    var LBound : Bound .
    var LDepth : Nat .

    op start : Program -> ConcolicState .
    op start : ConstrainedStart -> ConcolicState .
    eq start(P) = $start(P, nil, empty, true, unbounded) .
    eq start(P where BExp) = $start(P, nil, empty, BExp, unbounded) .
    op start : Program Program -> ConcolicState .
    op start : ConstrainedStart Program -> ConcolicState .
    op start : Program Program Bound -> ConcolicState .
    op start : ConstrainedStart Program Bound -> ConcolicState .
    eq start(P, SVDeclL) = $start(P, SVDeclL, empty, true, unbounded) .
    eq start(P where BExp, SVDeclL) = $start(P, SVDeclL, empty, BExp, unbounded) .
    eq start(P, SVDeclL, LBound) = $start(P, SVDeclL, empty, true, LBound) .
    eq start(P where BExp, SVDeclL, LBound) = $start(P, SVDeclL, empty, BExp, LBound) .
    op $start : Program Program Map{Var, Value} BExp Bound -> ConcolicState .
    eq $start(P, nil, STR, BExp, LBound) = [ < P | init-CStore(STR, BExp) > ] [ < P | STR > {BExp} < {nil} ] [size(BExp)] [STR] [0 / LBound] . *** Don't negate initial conditions, only path conditions
    eq $start(P, (Var := V ;) SVDeclL, STR, BExp, LBound) = $start(P, SVDeclL, insert(Var, V, STR), BExp, LBound) .

    rl [C-skip] : 
        [ < skip ; IL | STR > ] [ SEPState {Constraints} < {Path} ] [N]
        =>
        [ < IL | STR > ] [ SEPState {Constraints} < {Path skip} ] [N] .

    rl [C-assign] : 
        [ < Var := AExp ; IL | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N]
        =>
        [ < IL | insert(Var, eval(AExp, STR), STR) > ] [ < P | insert(Var, eval(AExp, SymbSTR), SymbSTR) > {Constraints} < {Path assign} ] [N] .

    crl [C-if..then] :
        [ < if BExp then { IL1 } else { IL2 } IL | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N]
        =>
        [ < IL1 IL | STR > ] [ < P | SymbSTR > {Constraints'} < {Path if1} ] [N]
        if Constraints' := (Constraints /\ eval(BExp, SymbSTR))
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) === (true).Boolean)) .
    
    crl [C-if..else-spawn] :
        [ < if BExp then { IL1 } else { IL2 } IL | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N] [STRInit] [LDepth / LBound]
        =>
        [ < P | init-CStore(STRInit, eval(Constraints', STR)) > ] [ < P | STRInit > {Constraints'} < {nil} ] [N + 1] [STRInit] [0 / LBound]
        if metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) === (true).Boolean))
        /\ Constraints' := (Constraints /\ (not eval(BExp, SymbSTR)))
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(Constraints', STR))) .

    crl [C-if..else] :
        [ < if BExp then { IL1 } else { IL2 } IL | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N]
        =>
        [ < IL2 IL | STR > ] [ < P | SymbSTR > {Constraints'} < {Path if2} ] [N]
        if Constraints' := (Constraints /\ (not eval(BExp, SymbSTR))) 
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) =/== (true).Boolean)) .
    
    crl [C-if..then-spawn] :
        [ < if BExp then { IL1 } else { IL2 } IL | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N] [STRInit] [LDepth / LBound]
        =>
        [ < P | init-CStore(STRInit, eval(Constraints', STR)) > ] [ < P | STRInit > {Constraints'} < {nil} ] [N + 1] [STRInit] [0 / LBound]
        if metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) =/== (true).Boolean))
        /\ Constraints' := (Constraints /\ eval(BExp, SymbSTR))
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(Constraints', STR))) .
    

    crl [C-while..loop] : 
        [ < while BExp do { IL1 } IL | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N] [STRInit] [LDepth / LBound]
        =>
        [ < IL1 while BExp do { IL1 } IL | STR > ] [ < P | SymbSTR > {Constraints'} < {Path while1} ] [N] [STRInit] [LDepth / LBound]
        if Constraints' := (Constraints /\ eval(BExp, SymbSTR))
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) === (true).Boolean)) .
    
    crl [C-while..exit-spawn] : 
        [ < while BExp do { IL1 } IL | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N] [STRInit] [LDepth / LBound]
        =>
        [ < P | init-CStore(STRInit, eval(Constraints', STR)) > ] [ < P | STRInit > {Constraints'} < {nil} ] [N + 1] [STRInit] [LDepth / LBound]
        if metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) === (true).Boolean))
        /\ Constraints' := (Constraints /\ (not eval(BExp, SymbSTR)))
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(Constraints', STR))) .
        
    crl [C-while..exit] : 
        [ < while BExp do { IL1 } IL | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N] [STRInit] [LDepth / LBound]
        =>
        [ < IL | STR > ] [ < P | SymbSTR > {Constraints'} < {Path while2} ] [N] [STRInit] [0 / LBound]
        if Constraints' := (Constraints /\ (not eval(BExp, SymbSTR))) 
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) =/== (true).Boolean)) .
    
    crl [C-while..loop-spawn] : 
        [ < while BExp do { IL1 } IL | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N] [STRInit] [LDepth / LBound]
        =>
        [ < P | init-CStore(STRInit, eval(Constraints', STR)) > ] [ < P | STRInit > {Constraints'} < {nil} ] [N + 1] [STRInit] [LDepth + 1 / LBound]
        if metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) =/== (true).Boolean))
        /\ Constraints' := (Constraints /\ eval(BExp, SymbSTR))
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(Constraints', STR)))
        /\ withinBounds(LDepth, LBound) .
    
    op withinBounds : Nat Bound -> Bool .
    eq withinBounds(LDepth, unbounded) = true .
    ceq withinBounds(LDepth, LBound) = true if LDepth < LBound .
    eq withinBounds(LDepth, LBound) = false [owise] .
    
    ***crl [reinit-Cexec-negInOrder] : 
    ***    [ < nil | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N] [STRInit]
    ***    =>
    ***    [ < P | init-CStore(STRInit, eval(Constraints', STR)) > ] [ < P | STRInit > {Constraints'} < {Path} ] [N + 1] [STRInit]
    ***    if N < size(Constraints)
    ***    /\ Constraints' := trunc-nth(negate-nth(Constraints, N), N)
    ***    /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(Constraints', STR))) . 
    ***
    ***crl [reinit-Cexec-negLast] : 
    ***    [ < nil | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N] [STRInit]
    ***    =>
    ***    [ < P | init-CStore(STRInit, eval(Constraints', STR)) > ] [ < P | STRInit > {Constraints'} < {Path} ] [N + 1] [STRInit]
    ***    if N < size(Constraints)
    ***    /\ Constraints' := negate-nth(Constraints, size(Constraints) - 1)
    ***    /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(Constraints', STR))) . 
    
    ***op trunc-nth : BExp Nat -> BExp .
    ***eq trunc-nth(C1 /\ Constraints, 0) = C1 .
    ***eq trunc-nth(C1, 0) = C1 .
    ***ceq trunc-nth((C1 /\ Constraints), NzN) = C1 /\ trunc-nth(Constraints, NzN - 1)
    ***    if NzN < size((C1 /\ Constraints)) .

    ***op negate-nth : BExp Nat -> BExp .
    ***eq negate-nth(C1 /\ Constraints, 0) = (not C1) /\ Constraints .
    ***eq negate-nth(C1, 0) = not C1 .
    ***ceq negate-nth(C1 /\ Constraints, NzN) = C1 /\ negate-nth(Constraints, NzN - 1)
    ***    if NzN < size(C1 /\ Constraints) . *** TODO: Multiple parses due to C1 being able to be _and_ too

    op init-CStore : Map{Var, Value} BExp -> Map{Var, Value} .
    ceq init-CStore(STR, Constraints) = $apply-SMTassignment(STR, get-SMTassignment(C1))
        if C1 := eval(Constraints, STR) .

    op $apply-SMTassignment : Map{Var, Value} Assignment -> Map{Var, Value} .
    eq $apply-SMTassignment((Var |-> val(R), STR), R <-- Rconc) = (Var |-> val(Rconc), STR) .
    eq $apply-SMTassignment((Var |-> val(R), STR), R <-- Rconc ; Assignment) = (Var |-> val(Rconc), $apply-SMTassignment(STR, Assignment)) .
    eq $apply-SMTassignment((Var |-> val(I), STR), I <-- Iconc) = (Var |-> val(Iconc), STR) .
    eq $apply-SMTassignment((Var |-> val(I), STR), I <-- Iconc ; Assignment) = (Var |-> val(Iconc), $apply-SMTassignment(STR, Assignment)) .
    eq $apply-SMTassignment(STR, failed) = STR .

    op size : BExp -> Nat .
    eq size(C1) = 1 .
    eq size ((C1 /\ Constraints)) = 1 + size(Constraints) .

endm