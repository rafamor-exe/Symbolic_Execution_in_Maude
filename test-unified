*** Concrete semantics SMT types (Just semantics) (full concrete program)

search start(var('var2) := val(1/1) ; if (var('var1) < var('var2)) then { var('var3) := val(0/1) ; if (var('var1) < val(0/1)) then { var('var3) := val(2/1) ; if (var('var1) < val(-1/1)) then { var('var3) := val(3/1) ; } } }, var('var1) := val(-1/1) ;) =>! FinalState:State .

*** Custom SE + Concolic
search start(var('var2) := val(1/1) ; if (var('var1) < var('var2)) then { var('var3) := val(0/1) ; if (var('var1) < val(0/1)) then { var('var3) := val(2/1) ; if (var('var1) < val(-1/1)) then { var('var3) := val(3/1) ; } } } where (p:Real < 5/1), var('var1) := val(p:Real) ;) =>! FinalState:SEState .
search start(var('z) := val(0) ; while (var('y) < var('x)) do { var('z) := var('z) + val(1) ; var('y) := var('y) + val(1) ; } where (p:Integer < 5 /\ (p:Integer > 0) /\ (q:Integer < 5 /\ (q:Integer > 0))), var('x) := val(p:Integer) ; var('y) := val(q:Integer) ;) =>! FinalState:SEState .

*** Concrete semantics SMT types + MaudeSE (only works without metaCheck conditions)
smt-search [1] in WHILE-MAUDE : start(var('var2) := val(1/1) ; if (var('var1) < var('var2)) then { var('var3) := val(0/1) ; if (var('var1) < val(0/1)) then { var('var3) := val(2/1) ; if (var('var1) < val(-1/1)) then { var('var3) := val(3/1) ; } } }, var('var1) := val(p:Real) ;) =>* < nil | STR:Map{Var, Value} > such that p:Real > -3/1 and p:Real < 5/1 using QF_LRA .
smt-search [2] in WHILE-MAUDE : start(var('var2) := val(1/1) ; if (var('var1) < var('var2)) then { var('var3) := val(0/1) ; if (var('var1) < val(0/1)) then { var('var3) := val(2/1) ; if (var('var1) < val(-1/1)) then { var('var3) := val(3/1) ; } } }, var('var1) := val(p:Real) ;) =>* < nil | STR:Map{Var, Value} > such that p:Real > -3/1 and p:Real < 5/1 using QF_LRA .
smt-search [3] in WHILE-MAUDE : start(var('var2) := val(1/1) ; if (var('var1) < var('var2)) then { var('var3) := val(0/1) ; if (var('var1) < val(0/1)) then { var('var3) := val(2/1) ; if (var('var1) < val(-1/1)) then { var('var3) := val(3/1) ; } } }, var('var1) := val(p:Real) ;) =>* < nil | STR:Map{Var, Value} > such that p:Real > -3/1 and p:Real < 5/1 using QF_LRA .
smt-search [4] in WHILE-MAUDE : start(var('var2) := val(1/1) ; if (var('var1) < var('var2)) then { var('var3) := val(0/1) ; if (var('var1) < val(0/1)) then { var('var3) := val(2/1) ; if (var('var1) < val(-1/1)) then { var('var3) := val(3/1) ; } } }, var('var1) := val(p:Real) ;) =>* < nil | STR:Map{Var, Value} > such that p:Real > -3/1 and p:Real < 5/1 using QF_LRA .


Maude> red rlToSymbolic(rl upTerm('< 'skip ; 'IL '| 'STR '>) => upTerm('< 'IL '| 'STR '>) [none] . none) .
reduce in MODULE-TRANSFORMER : rlToSymbolic(rl upTerm('< 'skip ; 'IL '| 'STR '>) => upTerm('< 'IL '| 'STR '>) [none] .) .
rewrites: 4 in 0ms cpu (0ms real) (~ rewrites/second)
result [RuleSet]: rl '_;_['__[''<.Sort, ''skip.Sort], '__[''IL.Sort, ''|.Sort, ''STR.Sort, ''>.Sort]]{'Constraints}<{'Path}=> '__[''<.Sort, ''IL.Sort, ''|.Sort, ''STR.Sort, ''>.Sort]{
    'Constraints}<{'Path}[none].
---------------
Maude> red rlToSymbolic(rl upTerm('< 'skip ; IL:Term '| STR:Term '>) => upTerm('< IL:Term '| STR:Term '>) [none] . none) .
reduce in MODULE-TRANSFORMER : rlToSymbolic(rl upTerm('< 'skip ; IL:Term '| STR:Term '>) => upTerm('< IL:Term '| STR:Term '>) [none] .) .
rewrites: 4 in 0ms cpu (0ms real) (~ rewrites/second)
result [RuleSet]: rl '_;_['__[''<.Sort, ''skip.Sort], '__['IL:Term, ''|.Sort, 'STR:Term, ''>.Sort]]{'Constraints}<{'Path}=> '__[''<.Sort, 'IL:Term, ''|.Sort, 'STR:Term, ''>.Sort]{
    'Constraints}<{'Path}[none].
-------
Maude> red rlToSymbolic(rl a:Term => b:Term [none] .) .
reduce in MODULE-TRANSFORMER : rlToSymbolic(rl a:Term => b:Term [none] .) .
rewrites: 2 in 0ms cpu (0ms real) (~ rewrites/second)
result [RuleSet]: rl a:Term{'Constraints}<{'Path}=> b:Term{'Constraints}<{'Path}[none].

Maude> red rlToSymbolic(crl '<_|_>['__['if_then`{_`}else`{_`}['BExp:BExp, 'IL1:Program, 'IL2:Program], 'IL:Program], 'STR:Map`{Var`,Value`}] => '<_|_>['__['IL1:Program, 'IL:Program],    'STR:Map`{Var`,Value`}] if 'metaCheck['upModule[''WHILE-MAUDE.Sort, 'false.Bool], 'upTerm['eval['BExp:BExp, 'STR:Map`{Var`,Value`}]]] = 'true.Bool [label('if..then)] .) .
reduce in TEST-TRANSFORM : rlToSymbolic(crl '<_|_>['__['if_then`{_`}else`{_`}['BExp:BExp, 'IL1:Program, 'IL2:Program], 'IL:Program], 'STR:Map`{Var`,Value`}] => '<_|_>['__[
    'IL1:Program, 'IL:Program], 'STR:Map`{Var`,Value`}] if 'metaCheck['upModule[''WHILE-MAUDE.Sort, 'false.Bool], 'upTerm['eval['BExp:BExp, 'STR:Map`{Var`,Value`}]]] = 'true.Bool [
    label('if..then)] .) .
rewrites: 2 in 0ms cpu (0ms real) (~ rewrites/second)
result [RuleSet]: crl '<_|_>['__['if_then`{_`}else`{_`}['BExp:BExp, 'IL1:Program, 'IL2:Program], 'IL:Program], 'STR:Map`{Var`,Value`}]{'Constraints}<{'Path}=> '<_|_>['__['IL1:Program,
    'IL:Program], 'STR:Map`{Var`,Value`}]{'Constraints}<{'Path 'if..then}if 'metaCheck['upModule[''WHILE-MAUDE.Sort, 'false.Bool], 'Constraints '/\ ('upTerm['eval['BExp:BExp,
    'STR:Map`{Var`,Value`}]])] = 'true.Bool[none].

-------

red transformModSymb(upModule('WHILE-MAUDE, false), 'State) .
...
  rl '<_|_>['__['skip`;.Inst, 'IL:Program], 'STR:Map`{Var`,Value`}]{'Constraints}<{'Path}=> '<_|_>['IL:Program, 'STR:Map`{Var`,Value`}]{'Constraints}<{'Path 'skip}[none].
  rl '<_|_>['__['_:=_;['Var:Var, 'AExp:AExp], 'IL:Program], 'STR:Map`{Var`,Value`}]{'Constraints}<{'Path}=> '<_|_>['IL:Program, 'insert['Var:Var, 'eval['AExp:AExp,
    'STR:Map`{Var`,Value`}], 'STR:Map`{Var`,Value`}]]{'Constraints}<{'Path 'assign}[none].
  crl '<_|_>['__['if_then`{_`}else`{_`}['BExp:BExp, 'IL1:Program, 'IL2:Program], 'IL:Program], 'STR:Map`{Var`,Value`}]{'Constraints}<{'Path}=> '<_|_>['__['IL1:Program, 'IL:Program],
    'STR:Map`{Var`,Value`}]{'Constraints}<{'Path 'if..then}if 'metaCheck['upModule[''WHILE-MAUDE.Sort, 'false.Bool], 'Constraints '/\ ('upTerm['eval['BExp:BExp,
    'STR:Map`{Var`,Value`}]])] = 'true.Bool[none].
  crl '<_|_>['__['if_then`{_`}else`{_`}['BExp:BExp, 'IL1:Program, 'IL2:Program], 'IL:Program], 'STR:Map`{Var`,Value`}]{'Constraints}<{'Path}=> '<_|_>['__['IL2:Program, 'IL:Program],
    'STR:Map`{Var`,Value`}]{'Constraints}<{'Path 'if..else}if 'metaCheck['upModule[''WHILE-MAUDE.Sort, 'false.Bool], 'Constraints '/\ ('upTerm['not_['eval['BExp:BExp,
    'STR:Map`{Var`,Value`}]]])] = 'true.Bool[none].
  crl '<_|_>['__['while_do`{_`}['BExp:BExp, 'IL1:Program], 'IL:Program], 'STR:Map`{Var`,Value`}]{'Constraints}<{'Path}=> '<_|_>['IL:Program, 'STR:Map`{Var`,Value`}]{'Constraints}<{
    'Path 'while..exit}if 'metaCheck['upModule[''WHILE-MAUDE.Sort, 'false.Bool], 'Constraints '/\ ('upTerm['not_['eval['BExp:BExp, 'STR:Map`{Var`,Value`}]]])] = 'true.Bool[none].
  crl '<_|_>['__['while_do`{_`}['BExp:BExp, 'IL1:Program], 'IL:Program], 'STR:Map`{Var`,Value`}]{'Constraints}<{'Path}=> '<_|_>['__['IL1:Program, '__['while_do`{_`}['BExp:BExp,
    'IL1:Program], 'IL:Program]], 'STR:Map`{Var`,Value`}]{'Constraints}<{'Path 'while..loop}if 'metaCheck['upModule[''WHILE-MAUDE.Sort, 'false.Bool], 'Constraints '/\ ('upTerm['eval[
    'BExp:BExp, 'STR:Map`{Var`,Value`}]])] = 'true.Bool[none].
endm


red searchSymb('WHILE-MAUDE, 'State, start(var('var2) := val(1/1) ; if (var('var1) < var('var2)) then { var('var3) := val(0/1) ; if (var('var1) < val(0/1)) then { var('var3) := val(2/1) ; if (var('var1) < val(-1/1)) then { var('var3) := val(3/1) ; } } } where (p:Real < 5/1), var('var1) := val(p:Real) ;), FinalState:SEState, nil, '!, unbounded, 0) .

red searchSymb('WHILE-MAUDE, 'State, upTerm('< 'var('var2) := 'val('1/1) ; 'if ('var('var1) '< 'var('var2)) 'then '{ 'var('var3) ':= 'val('0/1) ; '} '| var('var1) |-> val(p:Real) > {p:Real < 5/1} < {nil}), 'FinalState:SEState, nil, '!, unbounded, 0) .

red searchSymb('WHILE-MAUDE, 'State, < var('var2) := val(1/1) ; if (var('var1) < var('var2)) then { var('var3) := val(0/1) ; } | var('var1) |-> val(p:Real) > {p:Real < 5/1} < {nil}, 'FinalState:SEState, nil, '!, unbounded, 0) .

*** Try this (not working):
red metaParse(transformModSymb(upModule('WHILE-MAUDE, false), 'State), tokenize("< var('var2) := val(1/1) ; | var('var1) |-> val(p:Real) > {p:Real < 5/1} < {nil}"), 'SEState) .