*** Concrete semantics SMT types (Just semantics) (full concrete program)

search start(var('var2) := val(1/1) ; if (var('var1) < var('var2)) then { var('var3) := val(0/1) ; if (var('var1) < val(0/1)) then { var('var3) := val(2/1) ; if (var('var1) < val(-1/1)) then { var('var3) := val(3/1) ; } } }, var('var1) := val(-1/1) ;) =>! FinalState:State .

*** Custom SE + Concolic
search start(var('var2) := val(1/1) ; if (var('var1) < var('var2)) then { var('var3) := val(0/1) ; if (var('var1) < val(0/1)) then { var('var3) := val(2/1) ; if (var('var1) < val(-1/1)) then { var('var3) := val(3/1) ; } } } where (p:Real < 5/1), var('var1) := val(p:Real) ;) =>! FinalState:SEState .
search start(var('z) := val(0) ; while (var('y) < var('x)) do { var('z) := var('z) + val(1) ; var('y) := var('y) + val(1) ; } where (p:Integer < 5 /\ (p:Integer > 0) /\ (q:Integer < 5 /\ (q:Integer > 0))), var('x) := val(p:Integer) ; var('y) := val(q:Integer) ;) =>! FinalState:SEState .

*** Concrete semantics SMT types + MaudeSE (only works without metaCheck conditions)
smt-search [1] in WHILE-MAUDE : start(var('var2) := val(1/1) ; if (var('var1) < var('var2)) then { var('var3) := val(0/1) ; if (var('var1) < val(0/1)) then { var('var3) := val(2/1) ; if (var('var1) < val(-1/1)) then { var('var3) := val(3/1) ; } } }, var('var1) := val(p:Real) ;) =>* < nil | STR:Map{Var, Value} > such that p:Real > -3/1 and p:Real < 5/1 using QF_LRA .
smt-search [2] in WHILE-MAUDE : start(var('var2) := val(1/1) ; if (var('var1) < var('var2)) then { var('var3) := val(0/1) ; if (var('var1) < val(0/1)) then { var('var3) := val(2/1) ; if (var('var1) < val(-1/1)) then { var('var3) := val(3/1) ; } } }, var('var1) := val(p:Real) ;) =>* < nil | STR:Map{Var, Value} > such that p:Real > -3/1 and p:Real < 5/1 using QF_LRA .
smt-search [3] in WHILE-MAUDE : start(var('var2) := val(1/1) ; if (var('var1) < var('var2)) then { var('var3) := val(0/1) ; if (var('var1) < val(0/1)) then { var('var3) := val(2/1) ; if (var('var1) < val(-1/1)) then { var('var3) := val(3/1) ; } } }, var('var1) := val(p:Real) ;) =>* < nil | STR:Map{Var, Value} > such that p:Real > -3/1 and p:Real < 5/1 using QF_LRA .
smt-search [4] in WHILE-MAUDE : start(var('var2) := val(1/1) ; if (var('var1) < var('var2)) then { var('var3) := val(0/1) ; if (var('var1) < val(0/1)) then { var('var3) := val(2/1) ; if (var('var1) < val(-1/1)) then { var('var3) := val(3/1) ; } } }, var('var1) := val(p:Real) ;) =>* < nil | STR:Map{Var, Value} > such that p:Real > -3/1 and p:Real < 5/1 using QF_LRA .


Maude> red rlToSymbolic(rl upTerm('< 'skip ; 'IL '| 'STR '>) => upTerm('< 'IL '| 'STR '>) [none] . none) .
reduce in MODULE-TRANSFORMER : rlToSymbolic(rl upTerm('< 'skip ; 'IL '| 'STR '>) => upTerm('< 'IL '| 'STR '>) [none] .) .
rewrites: 4 in 0ms cpu (0ms real) (~ rewrites/second)
result [RuleSet]: rl '_;_['__[''<.Sort, ''skip.Sort], '__[''IL.Sort, ''|.Sort, ''STR.Sort, ''>.Sort]]{'Constraints}<{'Path}=> '__[''<.Sort, ''IL.Sort, ''|.Sort, ''STR.Sort, ''>.Sort]{
    'Constraints}<{'Path}[none].
---------------
Maude> red rlToSymbolic(rl upTerm('< 'skip ; IL:Term '| STR:Term '>) => upTerm('< IL:Term '| STR:Term '>) [none] . none) .
reduce in MODULE-TRANSFORMER : rlToSymbolic(rl upTerm('< 'skip ; IL:Term '| STR:Term '>) => upTerm('< IL:Term '| STR:Term '>) [none] .) .
rewrites: 4 in 0ms cpu (0ms real) (~ rewrites/second)
result [RuleSet]: rl '_;_['__[''<.Sort, ''skip.Sort], '__['IL:Term, ''|.Sort, 'STR:Term, ''>.Sort]]{'Constraints}<{'Path}=> '__[''<.Sort, 'IL:Term, ''|.Sort, 'STR:Term, ''>.Sort]{
    'Constraints}<{'Path}[none].
-------
Maude> red rlToSymbolic(rl a:Term => b:Term [none] .) .
reduce in MODULE-TRANSFORMER : rlToSymbolic(rl a:Term => b:Term [none] .) .
rewrites: 2 in 0ms cpu (0ms real) (~ rewrites/second)
result [RuleSet]: rl a:Term{'Constraints}<{'Path}=> b:Term{'Constraints}<{'Path}[none].