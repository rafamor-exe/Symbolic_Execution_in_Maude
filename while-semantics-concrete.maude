load while-semantics-basics-maudeTypes.maude

mod WHILE-MAUDE is

    pr WHILE-SE-BASICS .

    sort State .
    
    op < _ | _ > : Program Map{Var, Value} -> State [ctor] . 
    op errState : -> State [ctor] . 

    vars Var Var1 Var2 : Var .
    var BExp BExp2 : BExp .
    vars IL IL1 IL2 P : Program .
    vars STR STR2 : Map{Var, Value} .
    var AExp : AExp .
    var SVDeclL : Program .
    var V : Value .

    op start : Program -> State .
    eq start(P) = $start(P, nil, empty) .
    op start : Program Program -> State .
    eq start(P, nil) = $start(P, nil, empty) .
    eq start(P, (Var := V ;) SVDeclL) = $start(P, (Var := V ;) SVDeclL, empty) .
    op $start : Program Program Map{Var, Value} -> State .
    eq $start(P, nil, STR) = < P | STR > .
    eq $start(P, (Var := V ;) SVDeclL, STR) = $start(P, SVDeclL, insert(Var, V, STR)) .

    rl [skip] : 
        < skip ; IL | STR >
        =>
        < IL | STR > .

    rl [assign] : 
        < Var := AExp ; IL | STR >
        =>
        < IL | insert(Var, eval(AExp, STR), STR) > .

    crl [if..then] : 
        < if BExp then { IL1 } else { IL2 } IL | STR >
        =>
        < IL1 IL | STR >
        if eval(BExp, STR) = val(true) .

    crl [if..else] : 
        < if BExp then { IL1 } else { IL2 } IL | STR >
        =>
        < IL2 IL | STR >
        if (not eval(BExp, STR)) = val(true) .
    

    crl [while..loop] : 
        < while BExp do { IL1 } IL | STR >
        =>
        < IL1 while BExp do { IL1 } IL | STR >
        if eval(BExp, STR) = val(true) .
        
    crl [while..exit] : 
        < while BExp do { IL1 } IL | STR >
        =>
        < IL | STR >
        if (not eval(BExp, STR)) = val(true) .

    *** Auxiliary

    op getProgram : State -> Program .
    eq getProgram(< P | STR >) = P .

    op getStore : State -> Map{Var, Value} .
    eq getStore(< P | STR >) = STR .

    op updateProgram : State Program -> State .
    eq updateProgram(< P | STR >, IL) = < IL | STR > .

    op updateStore : State Map{Var, Value} -> State .
    eq updateStore(< P | STR >, STR2) = < P | STR2 > .
    
    op insertToSt : State Var Value -> State .
    eq insertToSt(< P | STR >, Var, V) = < P | insert(Var, V, STR) > .

    
    *** Ignore
    op test : Bool Int -> Rat .
endm