load smt.maude .

view Real from TRIV to REAL is
  sort Elt to Real .
endv

fmod WHILE-LANG-VARSTATE-MOD is

    pr REAL-INTEGER .
    pr BOOLEAN .

    sort AExp BExp .
    sort VarState .
    sorts VarType Value .
    sorts RVal BVal .
    subsort RVal BVal < Value < AExp .
    subsort Real < AExp .
    subsort Boolean < BExp .

    ops boolean real : -> VarType [ctor] .

    op val : Real -> RVal [ctor] .
    op val : Boolean -> BVal [ctor] .

    op {type _, val _} : VarType Value -> VarState [ctor] .

    var T : VarType .
    var V : Value .
    var R : Real .
    var B : Boolean .

    op getType : VarState -> VarType .
    eq getType({type T, val V}) = T .

    op getVal : VarState -> Value .
    eq getVal({type T, val V}) = V .

endfm

view VarState from TRIV to WHILE-LANG-VARSTATE-MOD is
  sort Elt to VarState .
endv

fmod WHILE-LANG-VAR-MOD is

    pr QID .
    pr WHILE-LANG-VARSTATE-MOD .

    sort Var .
    subsort Qid < Var < AExp .

    ***op var : String -> Var [ctor] .

endfm

view Var from TRIV to WHILE-LANG-VAR-MOD is
  sort Elt to Var .
endv

fmod WHILE-LANG-AEXP-MOD is

    pr WHILE-LANG-VAR-MOD .
    pr MAP{Var, Real} .

    op _+_ : AExp AExp -> AExp [ditto] .
    op _*_ : AExp AExp -> AExp [ditto] .
    op _-_ : AExp AExp -> AExp [ditto] .
    op _/_ : AExp AExp -> AExp [ditto] .

    op _=_ : AExp AExp -> BExp .
    op _!=_ : AExp AExp -> BExp .
    op _<_ : AExp AExp -> BExp [ditto] .
    op _<=_ : AExp AExp -> BExp [ditto] .
    op _>_ : AExp AExp -> BExp [ditto] .
    op _>=_ : AExp AExp -> BExp [ditto] .
    op _and_ : BExp BExp -> BExp [ditto] .

    op eval : BExp -> Boolean .
    op eval : AExp Map{Var, Real} -> Real .
    op eval : BExp Map{Var, Real} -> Boolean .

    var R R1 : Real .
    var AExp AExp1 AExp2 : AExp .
    var B : Boolean .
    var BExp : BExp .
    var STR : Map{Var, Real} .
    var Var : Var .

    eq eval(AExp1 + AExp2, STR) = eval(AExp1, STR) + eval(AExp2, STR) .
    eq eval(AExp1 * AExp2, STR) = eval(AExp1, STR) * eval(AExp2, STR) .
    eq eval(AExp1 - AExp2, STR) = eval(AExp1, STR) - eval(AExp2, STR) .
    eq eval(AExp1 / AExp2, STR) = eval(AExp1, STR) / eval(AExp2, STR) .
    eq eval(AExp1 = AExp2, STR) = eval(AExp1, STR) === eval(AExp2, STR) .
    eq eval(AExp1 != AExp2, STR) = eval(AExp1, STR) =/== eval(AExp2, STR) .
    eq eval(AExp1 < AExp2, STR) = eval(AExp1, STR) < eval(AExp2, STR) .
    eq eval(AExp1 <= AExp2, STR) = eval(AExp1, STR) <= eval(AExp2, STR) .
    eq eval(AExp1 > AExp2, STR) = eval(AExp1, STR) > eval(AExp2, STR) .
    eq eval(AExp1 >= AExp2, STR) = eval(AExp1, STR) >= eval(AExp2, STR) .
    eq eval(Var, ((Var |-> R), STR)) = R .
    eq eval(R, STR) = R .
    eq eval(B, STR) = B .

endfm

fmod WHILE-LANG-INSTS-MOD is

    pr WHILE-LANG-AEXP-MOD .

    sort Inst .
    sorts Skip AssignOp .
    subsort Skip AssignOp < Inst .

    op skip ; : -> Skip [ctor prec 20] .
    op _ := _ ; : Var AExp -> AssignOp [ctor prec 20] .
    ***op _ := _ ; : String Boolean -> AssignOp [ctor prec 20] .
    ***op _ := _ ; : String String -> AssignOp [ctor prec 20] .

endfm

view Inst from TRIV to WHILE-LANG-INSTS-MOD is
  sort Elt to Inst .
endv

fmod WHILE-LANG-BLOCK-MOD is

    pr WHILE-LANG-INSTS-MOD .
    pr LIST{Inst} .

    sorts IfElse While .
    subsort IfElse While < Inst .

    op if _ then {_} else {_} : BExp List{Inst} List{Inst} -> IfElse [ctor prec 20] .
    op if _ then {_} : BExp List{Inst} -> IfElse [ctor prec 20] .

    op while _ do {_} : BExp List{Inst} -> While [ctor prec 20] .

    var B : BExp .
    var IL1 : List{Inst} .

    eq if B then {IL1} = if B then {IL1} else {nil} .

endfm

fmod WHILE-LANG-SE-LOCS-MOD is
    sort Location .
    ops skip assign if1 if2 while1 while2 : -> Location [ctor] .
endfm

view Location from TRIV to WHILE-LANG-SE-LOCS-MOD is
  sort Elt to Location .
endv

fmod CONCRETE-STATE-MOD is
    pr RAT .
    pr MAP{Var, Rat} .
    sort ConAExp ConBExp AssignOp .
    ***subsort Qid < Var < ConAExp .
    ***subsort Rat < ConAExp .
    ***subsort Bool < ConBExp .

    op _ := _ ; : Var ConAExp -> AssignOp [ctor prec 20] .

***    op _+_ : ConAExp ConAExp -> ConAExp [ditto] .
***    op _*_ : ConAExp ConAExp -> ConAExp [ditto] .
***    op _-_ : ConAExp ConAExp -> ConAExp [ditto] .
***    op _/_ : ConAExp ConAExp -> ConAExp [ditto] .
***
***    op _=_ : ConAExp ConAExp -> ConBExp .
***    op _!=_ : ConAExp ConAExp -> ConBExp .
***    op _<_ : ConAExp ConAExp -> ConBExp [ditto] .
***    op _<=_ : ConAExp ConAExp -> ConBExp [ditto] .
***    op _>_ : ConAExp ConAExp -> ConBExp [ditto] .
***    op _>=_ : ConAExp ConAExp -> ConBExp [ditto] .
***    op _and_ : ConBExp ConBExp -> ConBExp [ditto] .
***
***    op eval : ConAExp -> Rat .
***    op eval : Rat -> Rat .
***    op eval : Bool -> Boolean .
***
***    var R R1 : Rat .
***    var ConAExp ConAExp1 ConAExp2 : ConAExp .
***    var B : Bool .
***    var BExp : BExp .
***    var STR : Map{Var, Rat} .
***    var Var : Var .
***    
***
***    eq eval(ConAExp1 + ConAExp2, STR) = eval(ConAExp1, STR) + eval(ConAExp2, STR) .
***    eq eval(ConAExp1 * ConAExp2, STR) = eval(ConAExp1, STR) * eval(ConAExp2, STR) .
***    eq eval(ConAExp1 - ConAExp2, STR) = eval(ConAExp1, STR) - eval(ConAExp2, STR) .
***    eq eval(ConAExp1 / ConAExp2, STR) = eval(ConAExp1, STR) / eval(ConAExp2, STR) .
***    eq eval(ConAExp1 = ConAExp2, STR) = eval(ConAExp1, STR) == eval(ConAExp2, STR) .
***    eq eval(ConAExp1 != ConAExp2, STR) = eval(ConAExp1, STR) =/= eval(ConAExp2, STR) .
***    eq eval(ConAExp1 < ConAExp2, STR) = eval(ConAExp1, STR) < eval(ConAExp2, STR) .
***    eq eval(ConAExp1 <= ConAExp2, STR) = eval(ConAExp1, STR) <= eval(ConAExp2, STR) .
***    eq eval(ConAExp1 > ConAExp2, STR) = eval(ConAExp1, STR) > eval(ConAExp2, STR) .
***    eq eval(ConAExp1 >= ConAExp2, STR) = eval(ConAExp1, STR) >= eval(ConAExp2, STR) .
***    eq eval(Var, ((Var |-> R), STR)) = R .
***    eq eval(R, STR) = R .
***    eq eval(B, STR) = B .
endfm

fmod SEMAPHORE is
    sort Sem .
    ops ok wait : -> Sem [ctor] .
endfm

mod WHILE-MAUDE is

    pr WHILE-LANG-BLOCK-MOD .
    pr WHILE-LANG-SE-LOCS-MOD .
    pr LIST{Location} * (sort List{Location} to Path) .
    pr META-LEVEL * (op _=_ to _=M_) * (op _+_ to _+M_) .
    pr CONCRETE-STATE-MOD .
    pr SEMAPHORE .

    sorts SEState PState ConcreteEState ConcolicState .
    sort ConstrainedStart .
    
    op {_} # _ | _ # : Sem List{Inst} Map{Var, Real} -> PState [ctor] . 
    op errState : -> PState [ctor] .

    op _ {_} # {_} : PState BExp Path -> SEState [ctor] . 

    op _ where _ : List{Inst} BExp -> ConstrainedStart [ctor] .

    op {_} # _ | _ # : Sem List{Inst} Map{Var, Rat} -> CEState [ctor] .

    op [_] [_] : SEState CEState -> ConcolicState [ctor] .


    vars Var Var1 Var2 : Var .
    var B : Boolean .
    var BExp BExp2 Constraints Constraints' : BExp .
    var RealVal : Real .
    vars IL IL1 IL2 : List{Inst} .
    var SymSTR : Map{Var, Real} .
    var VarState : VarState .
    var AExp : AExp .
    var Path : Path .
    var ConSTR : Map{Var, Rat} .
    var ConAExp : ConAExp .
    var RatVal : Rat .


    op start : List{Inst} -> ConcolicState . 
    op start : ConstrainedStart -> ConcolicState . 
    eq start(IL) = [ { wait } # IL | empty # {true} # {nil} ] [ { ok } # IL | empty # ] .
    eq start(IL where BExp) = [ { wait } # IL | empty # {BExp} # {nil} ] [ { ok } # IL | empty # ] .

    rl [sym-skip] : 
        {ok} # skip ; IL | SymSTR # {Constraints} # {Path}
        =>
        {ok} # IL | SymSTR # {Constraints} # {Path skip} .

    crl [sym-assign] : 
        {ok} # Var := AExp ; IL | SymSTR # {Constraints} # {Path}
        =>
        ***# IL | insert(Var, {type real, val eval(AExp, SymSTR)}, SymSTR) # .
        {ok} # IL | insert(Var, RealVal, SymSTR) # {Constraints} # {Path assign}
        if RealVal := eval(AExp, SymSTR) .
    
    ***rl [assign-boolean] : 
    ***    # Var := B ; IL | SymSTR #
    ***    =>
    ***    # IL | insert(Var, {type boolean, val val(B)}, SymSTR) # .
    ***
    ***crl [assign-var] : 
    ***    # Var := Var1 ; IL | SymSTR #
    ***    =>
    ***    # IL | insert(Var, {type getType(VarState), val getVal(VarState)}, SymSTR) #
    ***    if VarState := SymSTR[Var1] .

    crl [sym-if..then] : 
        {ok} # if BExp then { IL1 } else { IL2 } IL | SymSTR # {Constraints} # {Path}
        =>
        {ok} # IL1 IL | SymSTR # {Constraints'} # {Path if1}
        if Constraints' := (Constraints and eval(BExp, SymSTR) === (true).Boolean)
           /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(Constraints')) .

    crl [sym-if..else] : 
        {ok} # if BExp then { IL1 } else { IL2 } IL | SymSTR # {Constraints} # {Path}
        =>
        {ok} # IL2 IL | SymSTR # {Constraints'} # {Path if2}
        if Constraints' := (Constraints and eval(BExp, SymSTR) =/== (true).Boolean)
           /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(Constraints')) .
    

    crl [sym-while..loop] : 
        {ok} # while BExp do { IL1 } IL | SymSTR # {Constraints} # {Path}
        =>
        {ok} # IL1 while BExp do { IL1 } IL | SymSTR # {Constraints'} # {Path while1}
        if Constraints' := (Constraints and eval(BExp, SymSTR) === (true).Boolean)
           /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(Constraints')) .
        
    crl [sym-while..exit] : 
        {ok} # while BExp do { IL1 } IL | SymSTR # {Constraints} # {Path}
        =>
        {ok} # IL | SymSTR # {Constraints'} # {Path while2}
        if Constraints' := (Constraints and eval(BExp, SymSTR) =/== (true).Boolean)
           /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(Constraints')) .
    
    rl [con-skip] : 
        {ok} # skip ; IL | ConSTR #
        =>
        {ok} # IL | ConSTR # .
    
    crl [con-assign] : 
        {ok} # Var := ConAExp ; IL | ConSTR #
        =>
        {ok} # IL | insert(Var, RatVal, ConSTR) #
        if RatVal := eval(ConAExp, ConSTR) .
endm