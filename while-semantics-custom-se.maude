load smt.maude .
load while-semantics-basics.maude

mod WHILE-MAUDE is

    pr WHILE-SE-BASICS .
    pr LIST{Location} * (sort List{Location} to Path) .
    pr META-LEVEL * (op _=_ to _=M_) * (op _+_ to _+M_) .

    sorts SEState PState .
    sort ConstrainedStart .
    
    op # _ | _ # : Program Map{Var, Value} -> PState [ctor] . 
    op errState : -> PState [ctor] .

    op _ {_} # {_} : PState BExp Path -> SEState [ctor] . 

    op _ where _ : Program BExp -> ConstrainedStart [ctor] .


    vars Var : Var .
    var B : Boolean .
    vars BExp BExp2 Constraints Constraints' : BExp .
    vars P IL IL1 IL2 : Program .
    var STR STR' : Map{Var, Value} .
    var AExp : AExp .
    var Path : Path .
    var SVDeclL : Program .
    var V : Value .

    op start : Program -> SEState .
    op start : ConstrainedStart -> SEState .
    eq start(P) = $start(P, nil, empty, true) .
    eq start(P where BExp) = $start(P, nil, empty, BExp) .
    op start : Program Program -> SEState .
    op start : ConstrainedStart Program -> SEState .
    eq start(P, SVDeclL) = $start(P, SVDeclL, empty, true) .
    eq start(P where BExp, SVDeclL) = $start(P, SVDeclL, empty, BExp) .
    op $start : Program Program Map{Var, Value} BExp -> SEState .
    eq $start(P, nil, STR, BExp) = # P | STR # {BExp} # {nil} .
    eq $start(P, (Var := V ;) SVDeclL, STR, BExp) = $start(P, SVDeclL, insert(Var, V, STR), BExp) .
    

    rl [skip] : 
        # skip ; IL | STR # {Constraints} # {Path}
        =>
        # IL | STR # {Constraints} # {Path skip} .

    rl [assign] : 
        # Var := AExp ; IL | STR # {Constraints} # {Path}
        =>
        # IL | insert(Var, eval(AExp, STR), STR) # {Constraints} # {Path assign} .

    crl [if..then] : 
        # if BExp then { IL1 } else { IL2 } IL | STR # {Constraints} # {Path}
        =>
        # IL1 IL | STR # {Constraints'} # {Path if1}
        if Constraints' := (Constraints /\ eval(BExp, STR))
           /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(Constraints', STR))) .

    crl [if..else] : 
        # if BExp then { IL1 } else { IL2 } IL | STR # {Constraints} # {Path}
        =>
        # IL2 IL | STR # {Constraints'} # {Path if2}
        if Constraints' := (Constraints /\ (not eval(BExp, STR)))
           /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(Constraints', STR))) .

    crl [while..loop] : 
        # while BExp do { IL1 } IL | STR # {Constraints} # {Path}
        =>
        # IL1 while BExp do { IL1 } IL | STR # {Constraints'} # {Path while1}
        if Constraints' := (Constraints /\ eval(BExp, STR))
           /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(Constraints', STR))) .
        
    crl [while..exit] : 
        # while BExp do { IL1 } IL | STR # {Constraints} # {Path}
        =>
        # IL | STR # {Constraints'} # {Path while2}
        if Constraints' := (Constraints /\ (not eval(BExp, STR)))
           /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(Constraints', STR))) .

endm