load smt.maude

view Real from TRIV to REAL is
  sort Elt to Real .
endv

fmod WHILE-LANG-VARSTATE-MOD is

    pr REAL-INTEGER .
    pr BOOLEAN .

    sort AExp BExp .
    sort VarState .
    sorts VarType Value .
    sorts RVal BVal IVal .
    subsort RVal IVal < Value < AExp .
    subsort BVal < BExp .

    ops boolean real integer : -> VarType [ctor] .

    op val : Real -> RVal [ctor] .
    op val : Integer -> IVal [ctor] .
    op val : Boolean -> BVal [ctor] .

    op {type _, val _} : VarType Value -> VarState [ctor] .

    var T : VarType .
    var V V1 V2 : Value .
    var R R1 R2 : Real .
    var B : Boolean .

    op getType : VarState -> VarType .
    eq getType({type T, val V}) = T .

    op getVal : VarState -> Value .
    eq getVal({type T, val V}) = V .

endfm

view Value from TRIV to WHILE-LANG-VARSTATE-MOD is
  sort Elt to Value .
endv

view VarState from TRIV to WHILE-LANG-VARSTATE-MOD is
  sort Elt to VarState .
endv

fmod WHILE-LANG-VAR-MOD is

    pr QID .
    pr WHILE-LANG-VARSTATE-MOD .

    sort Var SVDecl .
    subsort Qid < Var < AExp .

    ***op var : String -> Var [ctor] .
    op _:_ : Var VarType -> SVDecl [ctor] .

endfm

view Var from TRIV to WHILE-LANG-VAR-MOD is
  sort Elt to Var .
endv

view SVDecl from TRIV to WHILE-LANG-VAR-MOD is
  sort Elt to SVDecl .
endv

fmod WHILE-LANG-AEXP-MOD is

    pr WHILE-LANG-VAR-MOD .
    pr MAP{Var, VarState} .

    var R R1 R2 : Real .
    var I I1 I2 : Integer .

    op _+_ : AExp AExp -> AExp .
    op _*_ : AExp AExp -> AExp .
    op _-_ : AExp AExp -> AExp .
    op _/_ : AExp AExp -> AExp .

    op _=_ : AExp AExp -> BExp .
    op _!=_ : AExp AExp -> BExp .
    op _<_ : AExp AExp -> BExp .
    op _<=_ : AExp AExp -> BExp .
    op _>_ : AExp AExp -> BExp .
    op _>=_ : AExp AExp -> BExp .

    ***op _===_ : Value Value -> Boolean .
    ***eq val(R1) === val(R2) = R1 === R2 .
    ***eq val(I1) === val(I2) = I1 === I2 .
    ***op _=/==_ : Value Value -> Boolean .
    ***eq val(R1) =/== val(R2) = R1 =/== R2 .
    ***eq val(I1) =/== val(I2) = I1 =/== I2 .
    ***op _<_ : Value Value -> Boolean .

    op eval : BExp -> Boolean .
    op eval : AExp Map{Var, VarState} -> Real .
    op eval : BExp Map{Var, VarState} -> Boolean .

    var AExp AExp1 AExp2 : AExp .
    var B : Boolean .
    var BExp : BExp .
    var STR : Map{Var, VarState} .
    var Var : Var .
    var T : VarType .

    eq eval(AExp1 + AExp2, STR) = eval(AExp1, STR) + eval(AExp2, STR) .
    eq eval(AExp1 * AExp2, STR) = eval(AExp1, STR) * eval(AExp2, STR) .
    eq eval(AExp1 - AExp2, STR) = eval(AExp1, STR) - eval(AExp2, STR) .
    eq eval(AExp1 / AExp2, STR) = eval(AExp1, STR) / eval(AExp2, STR) .
    eq eval(AExp1 = AExp2, STR) = eval(AExp1, STR) === eval(AExp2, STR) .
    eq eval(AExp1 != AExp2, STR) = eval(AExp1, STR) =/== eval(AExp2, STR) .
    eq eval(AExp1 < AExp2, STR) = eval(AExp1, STR) < eval(AExp2, STR) .
    eq eval(AExp1 <= AExp2, STR) = eval(AExp1, STR) <= eval(AExp2, STR) .
    eq eval(AExp1 > AExp2, STR) = eval(AExp1, STR) > eval(AExp2, STR) .
    eq eval(AExp1 >= AExp2, STR) = eval(AExp1, STR) >= eval(AExp2, STR) .
    eq eval(Var, ((Var |-> {type T, val val(R)}), STR)) = R .
    ***eq eval(Var, ((Var |-> {type T, val val(I)}), STR)) = val(I) .
    eq eval(val(R), STR) = R .
    ***eq eval(val(I), STR) = val(I) .
    eq eval(val(B), STR) = B .

endfm

fmod WHILE-LANG-INSTS-MOD is

    pr WHILE-LANG-AEXP-MOD .

    sort Inst .

    op skip ; : -> Inst [ctor prec 20] .
    op _ _ := _ ; : VarType Var AExp -> Inst [ctor prec 20] .
    op _ := _ ; : Var AExp -> Inst [ctor prec 20] .

endfm

view Inst from TRIV to WHILE-LANG-INSTS-MOD is
  sort Elt to Inst .
endv

fmod WHILE-LANG-BLOCK-MOD is

    pr WHILE-LANG-INSTS-MOD .
    pr LIST{Inst} * (sort List{Inst} to Program) .

    op if _ then {_} else {_} : BExp Program Program -> Inst [ctor prec 20] .
    op if _ then {_} : BExp Program -> Inst [prec 20] .

    op while _ do {_} : BExp Program -> Inst [ctor prec 20] .

    var B : BExp .
    var IL1 : Program .

    eq if B then {IL1} = if B then {IL1} else {nil} .

endfm

mod WHILE-MAUDE is

    pr WHILE-LANG-BLOCK-MOD .
    ***pr LIST{AssignOp} * (sort List{AssignOp} to SVDeclL) . *** fails preregularity checks

    sort State .
    
    op # _ | _ # : Program Map{Var, VarState} -> State [ctor] . 
    op errState : -> State [ctor] . 

    vars Var Var1 Var2 : Var .
    var B : Boolean .
    var BExp BExp2 : BExp .
    var RealVal : Real .
    vars IL IL1 IL2 P : Program .
    var STR : Map{Var, VarState} .
    var VarState : VarState .
    var AExp : AExp .
    var SVDeclL : Program .
    var T : VarType .
    var V : Value .

    op start : Program -> State .
    eq start(P) = $start(P, nil, empty) .
    op start : Program Program -> State .
    eq start(P, nil) = $start(P, nil, empty) .
    eq start(P, (T Var := V ;) SVDeclL) = $start(P, (T Var := V ;) SVDeclL, empty) .
    op $start : Program Program Map{Var, VarState} -> State .
    eq $start(P, nil, STR) = # P | STR # .
    eq $start(P, (T Var := V ;) SVDeclL, STR) = $start(P, SVDeclL, insert(Var, {type T, val V}, STR)) .
    ***eq $start(P, (Var : T) SVDeclL, STR) = # IL | insert(Var, {type T, val newVar(T, N)}, STR) # . *** Later, to create vars programatically without initial SMT value input

    rl [skip] : 
        # skip ; IL | STR #
        =>
        # IL | STR # .

    rl [assign-decl] : 
        # T Var := AExp ; IL | STR #
        =>
        # IL | insert(Var, {type T, val val(eval(AExp, STR))}, STR) # .
    
    crl [assign] : 
        # Var := AExp ; IL | STR #
        =>
        # IL | insert(Var, {type T, val val(eval(AExp, STR))}, STR) #
        if {type T, val V} := STR[Var] .

    crl [if..then] : 
        # if BExp then { IL1 } else { IL2 } IL | STR #
        =>
        # IL1 IL | STR #
        if eval(BExp, STR) = true .

    crl [if..else] : 
        # if BExp then { IL1 } else { IL2 } IL | STR #
        =>
        # IL2 IL | STR #
        if eval(BExp, STR) =/== true = true .
    

    crl [while..loop] : 
        # while BExp do { IL1 } IL | STR #
        =>
        # IL1 while BExp do { IL1 } IL | STR #
        if eval(BExp, STR) = true .
        
    crl [while..exit] : 
        # while BExp do { IL1 } IL | STR #
        =>
        # IL | STR #
        if eval(BExp, STR) =/== true = true .
endm