load ../semantics-basics/semantics-basics-maudeTypes.maude

fmod REC-LANG-TERM-MOD is

    protecting CONCRETE-AEXP-MOD .

    sorts RECTerm RECIVal .
    subsort RECIVal < IVal .
    subsort IExp RECIVal < RECTerm .

    op recVal : Int -> RECIVal [ctor] .

    op _+_ : RECTerm RECTerm -> RECTerm [gather (E e) prec 33] .
    op _-_ : RECTerm RECTerm -> RECTerm [gather (E e) prec 33] .
    op _*_ : RECTerm RECTerm -> RECTerm [gather (E e) prec 31] .

    var I : Int .
    var ISTR : IStore .
    eq evalI(recVal(I), ISTR) = I .
    
endfm

view RECTerm from TRIV to REC-LANG-TERM-MOD is
  sort Elt to RECTerm .
endv

fmod REC-LANG-BLOCK-MOD is

    protecting REC-LANG-TERM-MOD .
    protecting LIST{RECTerm} * (sort List{RECTerm} to Program) .
    protecting QID .

    sorts FTerm FDecl .
    sorts Args NeArgs .
    subsort FTerm < RECTerm < NeArgs < Args .

    op if _ then {_} else {_} : RECTerm RECTerm RECTerm -> RECTerm [ctor prec 20] .
    op if _ then {_} : RECTerm RECTerm -> RECTerm [prec 20] .

    op _ ',_ : Args Args -> Args [ctor id: nil] .
    op _ ',_ : NeArgs Args -> NeArgs [ctor ditto] .
    op _ ',_ : Args NeArgs -> NeArgs [ctor ditto] .

    op _[] : Qid -> FTerm [prec 20] .
    op _[_] : Qid Args -> FTerm [ctor prec 20] .

    vars T B : RECTerm .
    var IL1 : Program .
    var F : Qid .

    eq if B then {IL1} = if B then {IL1} else {nil} .

    eq F [] = F [nil] .

endfm
 
fmod REC-LANG-FUNCDEC-MOD is

    protecting REC-LANG-BLOCK-MOD .

    sort FDec .
    sorts ParamL NeParamL .
    subsort IVar < NeParamL < ParamL < Args .
    subsort NeParamL < NeArgs .

    op _ ',_ : ParamL ParamL -> ParamL [ctor id: nil] .
    op _ ',_ : NeParamL ParamL -> NeParamL [ctor ditto] .
    op _ ',_ : ParamL NeParamL -> NeParamL [ctor ditto] .

    op _[_]=_ : Qid ParamL RECTerm -> FDec [ctor prec 20] .

    var F : Qid .
    vars X Z : IVar .
    var ParamL : ParamL .
    var NeParamL : NeParamL .
    vars T T1 T2 Y : RECTerm .
    var Args : Args .
    var NeArgs : NeArgs .
    var V : IVal .

    op _[_] : FDec Args -> RECTerm [prec 10] .
    eq (F [nil] = T)[nil] = T .
    eq (F [X] = T)[Y] = (F [nil] = T[X / Y])[nil] .
    eq (F [X ', NeParamL] = T)[Y ', NeArgs] = (F [NeParamL] = T[X / Y])[NeArgs] .

    op _[_/_] : RECTerm IVar RECTerm -> RECTerm [prec 10] .
    eq V[X / Y] = V .
    eq X[X / Y] = Y .
    eq X[Z / Y] = X [owise] .
    eq (T1 + T2)[X / Y] = (T1[X / Y] + T2[X / Y]) .
    eq (T1 - T2)[X / Y] = (T1[X / Y] - T2[X / Y]) .
    eq (T1 * T2)[X / Y] = (T1[X / Y] * T2[X / Y]) .
    eq (if T then { T1 } else { T2 })[X / Y] = if T[X / Y] then { T1[X / Y] } else { T2[X / Y] } .
    
    eq (nil)[X / Y] = nil .
    eq (T  ', Args)[X / Y] = (T[X / Y] ', Args[X / Y]) .
    eq (F [Args])[X / Y] = F [Args[X / Y]] .
    
endfm

view FDec from TRIV to REC-LANG-FUNCDEC-MOD is
  sort Elt to FDec .
endv

fmod REC-BASICS is
    protecting REC-LANG-FUNCDEC-MOD .
    protecting LIST{FDec} * (sort List{FDec} to FDecL) .
endfm

mod REC-MAUDE is

    protecting REC-BASICS .
    protecting MAP{Qid, FDec} .

    sort State .
    
    op < _ | _ | _ > : Program Map{Qid, FDec} Stores -> State [ctor] . 
    op errState : Program Map{Qid, FDec} Stores -> State [ctor] . 

    vars IVar Var1 Var2 : IVar .
    var BExp BExp2 : BExp .
    vars IL IL1 IL2 P : Program .
    vars STR STR2 : Stores .
    var ISTR : IStore .
    var RSTR : RStore .
    var BSTR : BStore .
    var IExp : IExp .
    var V : IVal .
    vars T T1 T2 : RECTerm .
    var FDec : FDec .
    var FDecL : FDecL .
    var FSTR : Map{Qid, FDec} .
    var F : Qid .
    var ParamL : ParamL .
    var Args : Args .

    op start : Program FDecL -> State .
    eq start(P, FDecL) = start(P, FDecL, empty, (empty | empty | empty)) .
    op start : Program FDecL Map{Qid, FDec} Stores -> State .
    eq start(P, nil, FSTR, STR) = < P | FSTR | STR > .
    eq start(P, (F [ParamL] = T) FDecL, FSTR, STR) = start(P, FDecL, insert(F, (F [ParamL] = T), FSTR), STR) .

    rl [term-sum] :
        < T1 + T2 | FSTR | (ISTR | RSTR | BSTR) >
        =>
        < recVal(evalI(T1, ISTR) + evalI(T2, ISTR)) | FSTR | (ISTR | RSTR | BSTR) > .

    rl [term-subtract] :
        < T1 - T2 | FSTR | (ISTR | RSTR | BSTR) >
        =>
        < recVal(evalI(T1, ISTR) - evalI(T2, ISTR)) | FSTR | (ISTR | RSTR | BSTR) > .

    rl [term-mult] :
        < T1 * T2 | FSTR | (ISTR | RSTR | BSTR) >
        =>
        < recVal(evalI(T1, ISTR) * evalI(T2, ISTR)) | FSTR | (ISTR | RSTR | BSTR) > .

    rl [apply-func] :
        < F [Args] | (F |-> FDec, FSTR) | STR >
        =>
        < FDec[Args] | (F |-> FDec, FSTR) | STR > .

    crl [if..then] : 
        < if T then { T1 } else { T2 } | FSTR | (ISTR | RSTR | BSTR) >
        =>
        < T1 | FSTR | (ISTR | RSTR | BSTR) >
        if evalI(T, ISTR) == 0 .
        ***if T => val(0) .

    crl [if..else] : 
        < if T then { T1 } else { T2 } | FSTR | (ISTR | RSTR | BSTR) >
        =>
        < T2 | FSTR | (ISTR | RSTR | BSTR) >
        if not evalI(T, ISTR) == 0 .
        ***if T => val(N:NzInt) .

    *** Auxiliary

    op getProgram : State -> Program .
    eq getProgram(< P | FSTR | STR >) = P .

    op getStore : State -> Stores .
    eq getStore(< P | FSTR | STR >) = STR .

    op updateProgram : State Program -> State .
    eq updateProgram(< P | FSTR | STR >, IL) = < IL | FSTR | STR > .

    op updateStore : State Stores -> State .
    eq updateStore(< P | FSTR | STR >, STR2) = < P | FSTR | STR2 > .
    
    *** Ignore
    op test : Bool Int -> Rat .
endm