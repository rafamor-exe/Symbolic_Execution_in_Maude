load ../semantics-basics/semantics-basics-maudeTypes.maude

fmod WHILE-LANG-INSTS-MOD is

    protecting CONCRETE-AEXP-MOD .

    sort Inst .

    op skip ; : -> Inst [ctor prec 20] .
    op _ := _ ; : Var IExp -> Inst [ctor prec 20] .
    op _ := _ ; : Var RExp -> Inst [ctor prec 20] .
    op _ := _ ; : Var BExp -> Inst [ctor prec 20] .

endfm

view Inst from TRIV to WHILE-LANG-INSTS-MOD is
  sort Elt to Inst .
endv

fmod WHILE-LANG-BLOCK-MOD is

    protecting WHILE-LANG-INSTS-MOD .
    protecting LIST{Inst} * (sort List{Inst} to Program) .

    op if _ then {_} else {_} : BExp Program Program -> Inst [ctor prec 20] .
    op if _ then {_} : BExp Program -> Inst [prec 20] .

    op while _ do {_} : BExp Program -> Inst [ctor prec 20] .

    var B : BExp .
    var IL1 : Program .

    eq if B then {IL1} = if B then {IL1} else {nil} .

endfm

fmod WHILE-BASICS is
    protecting WHILE-LANG-BLOCK-MOD .
endfm

mod WHILE-MAUDE is

    protecting WHILE-BASICS .

    sort State .
    sorts CThread MTExec .
    subsort CThread Program < MTExec .

    op _ [_] : Program Nat -> CThread [ctor] .
    op noProgram : -> MTExec [ctor] .
    op _ || _ : MTExec MTExec -> MTExec [ctor assoc comm id: noProgram] .

    
    op < _ | _ > : MTExec Stores -> State [ctor] . 
    op errState : -> State [ctor] . 

    vars Var Var1 Var2 : Var .
    var IVar : IVar .
    var RVar : RVar .
    var BVar : BVar .
    var BExp BExp2 : BExp .
    vars IL IL1 IL2 : Program .
    vars STR STR2 : Stores .
    var ISTR : IStore .
    var RSTR : RStore .
    var BSTR : BStore .
    var IExp : IExp .
    var RExp : RExp .
    vars P PRest P2 : MTExec .

    op start : Program -> State .
    eq start(P) = < P | ((empty).IStore | (empty).RStore | (empty).BStore) > .

    rl [skip] : 
        < skip ; IL || PRest | STR >
        =>
        < IL || PRest | STR > .

    rl [assign-I] : 
        < IVar := IExp ; IL || PRest | (ISTR | RSTR | BSTR) >
        =>
        < IL || PRest | insert(IVar, eval(IExp, ISTR), ISTR) | RSTR | BSTR > .
    
    rl [assign-R] : 
        < RVar := RExp ; IL || PRest | (ISTR | RSTR | BSTR) >
        =>
        < IL || PRest | ISTR | insert(RVar, eval(RExp, RSTR), RSTR) | BSTR > .

    rl [assign-B] : 
        < BVar := BExp ; IL || PRest | (ISTR | RSTR | BSTR) >
        =>
        < IL || PRest | ISTR | RSTR | insert(BVar, eval(BExp, BSTR), BSTR) > .


    crl [if..then] : 
        < if BExp then { IL1 } else { IL2 } IL || PRest | STR >
        =>
        < IL1 IL || PRest | STR >
        if eval(BExp, STR) .

    crl [if..else] : 
        < if BExp then { IL1 } else { IL2 } IL || PRest | STR >
        =>
        < IL2 IL || PRest | STR >
        if not eval(BExp, STR) .
    

    crl [while..loop] : 
        < while BExp do { IL1 } IL || PRest | STR >
        =>
        < IL1 while BExp do { IL1 } IL || PRest | STR >
        if eval(BExp, STR) .
        
    crl [while..exit] : 
        < while BExp do { IL1 } IL || PRest | STR >
        =>
        < IL || PRest | STR >
        if not eval(BExp, STR) .

    *** Auxiliary

    op getProgram : State -> MTExec .
    eq getProgram(< P | STR >) = P .

    op getStore : State -> Stores .
    eq getStore(< P | STR >) = STR .

    op updateProgram : State MTExec -> State .
    eq updateProgram(< P | STR >, P2) = < P2 | STR > .

    op updateStore : State Stores -> State .
    eq updateStore(< P | STR >, STR2) = < P | STR2 > .
    
    *** Ignore
    op test : Bool Int -> Rat .
endm