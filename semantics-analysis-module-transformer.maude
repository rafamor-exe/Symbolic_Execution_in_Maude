load semantics-basics/semantics-basics-smtTypes.maude

*** Test transformer with while language module
load language-semantics/while-semantics-concrete.maude

fmod SMT-CONNECTION is
    pr REAL-INTEGER .

    sort AssignmentSMT .

    op _<--_ : Real Real -> AssignmentSMT [ctor] . *** test syntax
    op _<--_ : Integer Integer -> AssignmentSMT [ctor] . *** test syntax
    op _,_ : AssignmentSMT AssignmentSMT -> AssignmentSMT .
    op failed : -> AssignmentSMT [ctor] .

    op get-SMTassignment : Boolean -> AssignmentSMT [special (id-hook SpecialHubSymbol)] .

endfm

fmod SE-LOCS-MOD is
    protecting QID .
    sort Location .
    op loc : Qid -> Location [ctor] .
endfm

view Location from TRIV to SE-LOCS-MOD is
  sort Elt to Location .
endv

fmod MODULE-TRANSFORMER is
    pr META-LEVEL .
    pr STRING-OPS .

    vars Trm T1 T2 Tcond Tmod Constraints Path : Term .
    var AttrSet : AttrSet .
    var RlSet : RuleSet .
    var Cond : Condition .
    var Header : Header .
    var ImportList : ImportList .
    var SortSet : SortSet .
    var SubsortDeclSet : SubsortDeclSet .
    var OpDeclSet : OpDeclSet .
    var MembAxSet : MembAxSet .
    var EquationSet : EquationSet .
    vars InstId StateOp OpId ModId Q ValOp TrId : Qid .
    vars M AccM : Module .
    var TL : TypeList .
    var T : Type .
    var S1 S2 : Sort .
    var Import : Import .
    vars ModIdList QL : QidList .
    var TermL : TermList .
    var NeTL : NeTermList .
    var Smain S S' : String .
    var N? : FindResult .
    var MVar : Variable .
    var MConst : Constant .
    var B : Bool .

    op modRl : Module Qid Qid -> Module .
    eq modRl(M, StateOp, 'symb) = mod 'SYMBOLIC-MOD is
                                    getImports(M)
                                    sorts getSorts(M) .
                                    getSubsorts(M)
                                    getOps(M)
                                    getMbs(M)
                                    getEqs(M)
                                    rlToSymbolic(getRls(M), M)
                                  endm .
    eq modRl(M, StateOp, 'conc) = mod 'CONCOLIC-MOD is
                                    getImports(M)
                                    sorts getSorts(M) .
                                    getSubsorts(M)
                                    getOps(M)
                                    getMbs(M)
                                    getEqs(M)
                                    rlToConcolic(getRls(M), StateOp, M)
                                  endm .
    
    *** Generic Term substitution: substitute T1 by T2 in Trm
    op subT : Term Term Term -> Term .
    eq subT(MConst, MConst, T2) = T2 .
    eq subT(MVar, MVar, T2) = T2 .
    eq subT(OpId[Trm], T1, T2) = OpId[subT(Trm, T1, T2)] .
    eq subT(OpId[Trm, NeTL], T1, T2) = OpId[subT(Trm, T1, T2), subTL(NeTL, T1, T2)] .
    eq subT(Trm, T1, T2) = Trm [owise] .

    op subTL : TermList Term Term -> Term .
    eq subTL(empty, T1, T2) = empty .
    eq subTL(Trm, T1, T2) = subT(Trm, T1, T2) .
    eq subTL((Trm, NeTL), T1, T2) = subT(Trm, T1, T2), subTL(NeTL, T1, T2) .


    op rlToSymbolic : RuleSet Module -> RuleSet .
    eq rlToSymbolic(none, M) = none .
    eq rlToSymbolic(rl T1 => T2 [label(InstId) AttrSet] . RlSet, M) = rl '_`{_`}<`{_`}[T1, 'Constraints:Boolean, 'Path:Path] => '_`{_`}<`{_`}[T2, 'Constraints:Boolean, '__['Path:Path, 'loc[upTerm(InstId)]]] [label(InstId) AttrSet] . rlToSymbolic(RlSet, M) .
    *** TODO: parametrize language-specific sorts (Map, BExp)
    ceq rlToSymbolic(crl T1 => T2 if Cond [label(InstId) AttrSet] . RlSet, M) = crl '_`{_`}<`{_`}[T1, 'Constraints:Boolean, 'Path:Path] => '_`{_`}<`{_`}[T2, 'Constraints:Boolean, '__['Path:Path, 'loc[upTerm(InstId)]]] if 'Constraints':Boolean := '_and_['Constraints:Boolean, 'evalB[Tcond]] /\ 'metaCheck[upTerm(M), 'upTerm['Constraints':Boolean]] = 'true.Bool [label(InstId) AttrSet] . rlToSymbolic(RlSet, M)
        if (Tcond = 'val['true.Bool]) := Cond .
    
    *** TODO: Transform rules to concolic
    ***     - Take into account that symbolic rules must not be applied to internal symbolic state during concolic exec
    ***     - Create another module? Just changing the rules to use the underlying equational theory 
    
    op stateVar : Qid -> Variable .
    eq stateVar(StateOp) = qid(string('State) + ":" + string(StateOp)) .
    
    op rlToConcolic : RuleSet Qid Module -> RuleSet .
    eq rlToConcolic(none, StateOp, M) = none .
    *** '<_|_>['P:Program, 'SymbSTR:Map`{Var`,Value`}]
    eq rlToConcolic(rl T1 => T2 [label(InstId) AttrSet] . RlSet, StateOp, M) = (crl '`[_`]`[_`]`[_`]`[_`]`[_/_`][T1, '_`{_`}<`{_`}[stateVar(StateOp), 'Constraints:Boolean, 'Path:Path], 'N:Nat, 'STRInit:Map`{Var`,Value`}, 'LDepth:Nat, 'LBound:Bound]
                                                                               =>
                                                                               '`[_`]`[_`]`[_`]`[_`]`[_/_`][T2, '_`{_`}<`{_`}[stateVar(StateOp), 'Constraints:Boolean, '__['Path:Path, 'loc[upTerm(InstId)]]], 'N:Nat, 'STRInit:Map`{Var`,Value`}, 'LDepth:Nat, 'LBound:Bound]
                                                                               if '_==_['getStore[T1], 'getStore[T2]] = 'true.Bool
                                                                               [label(InstId) AttrSet] .)
                                                                               *** if the store is not the same update it in the symb state using the same mechanism as in the original rl but over the symb store
                                                                               (crl '`[_`]`[_`]`[_`]`[_`]`[_/_`][T1, '_`{_`}<`{_`}[stateVar(StateOp), 'Constraints:Boolean, 'Path:Path], 'N:Nat, 'STRInit:Map`{Var`,Value`}, 'LDepth:Nat, 'LBound:Bound]
                                                                               =>
                                                                               '`[_`]`[_`]`[_`]`[_`]`[_/_`][T2, '_`{_`}<`{_`}[subT('updateProgram[T2, 'getProgram[stateVar(StateOp)]], 'STR:Map`{Var`,Value`}, 'getStore[stateVar(StateOp)]), 'Constraints:Boolean, '__['Path:Path, 'loc[upTerm(InstId)]]], 'N:Nat, 'STRInit:Map`{Var`,Value`}, 'LDepth:Nat, 'LBound:Bound]
                                                                               if '_=/=_['getStore[T1], 'getStore[T2]] = 'true.Bool
                                                                               ***if 'insert['Var:Var, 'Val:Value, 'STR:Map`{Var`,Value`}] := 'getStore[T2]
                                                                               [label(qid(string(InstId) + "-bis")) AttrSet] .)
                                                                               rlToConcolic(RlSet, StateOp, M) .
    ***eq rlToConcolic(rl T1 => T2 [label(InstId) AttrSet] . RlSet, StateOp, M) = crl '`[_`]`[_`]`[_`]`[_`]`[_/_`][T1, '_`{_`}<`{_`}[stateVar(StateOp), 'Constraints:Boolean, 'Path:Path], 'N:Nat, 'STRInit:Map`{Var`,Value`}, 'LDepth:Nat, 'LBound:Bound]
    ***                                                                           =>
    ***                                                                           '`[_`]`[_`]`[_`]`[_`]`[_/_`][T2, '_`{_`}<`{_`}['insertToSt[stateVar(StateOp), 'Var:Var, 'Val:Value], 'Constraints:Boolean, '__['Path:Path, 'loc[upTerm(InstId)]]], 'N:Nat, 'STRInit:Map`{Var`,Value`}, 'LDepth:Nat, 'LBound:Bound]
    ***                                                                           if 'insert['Var:Var, 'Val:Value, 'STR:Map`{Var`,Value`}] := 'getStore[T2]
    ***                                                                           [label(InstId) AttrSet] .
    ***                                                                           rlToConcolic(RlSet, StateOp, M) .
    
    *** TODO: Generalize hardcoded STR variable indicating the concrete store
    ceq rlToConcolic(crl T1 => T2 if Cond [label(InstId) AttrSet] . RlSet, StateOp, M) = (crl '`[_`]`[_`]`[_`]`[_`]`[_/_`][T1, '_`{_`}<`{_`}[stateVar(StateOp), 'Constraints:Boolean, 'Path:Path], 'N:Nat, 'STRInit:Map`{Var`,Value`}, 'LDepth:Nat, 'LBound:Bound]
                                                                                    =>
                                                                                    '`[_`]`[_`]`[_`]`[_`]`[_/_`][T2, '_`{_`}<`{_`}[stateVar(StateOp), 'Constraints':Boolean, '__['Path:Path, 'loc[upTerm(InstId)]]], 'N:Nat, 'STRInit:Map`{Var`,Value`}, 'LDepth:Nat, 'LBound:Bound]
                                                                                    if 'Constraints':Boolean := '_and_['Constraints:Boolean, 'evalB[subT(Tcond, 'STR:Map`{Var`,Value`}, 'getStore[stateVar(StateOp)])]]
                                                                                    /\ 'metaCheck[upTerm(M), 'upTerm['evalB[Tcond]]] = 'true.Bool
                                                                                [label(InstId) AttrSet] .)
                                                                                *** TODO: Change resulting symbolic store to STRInit (it would probably be needed to inject subT into the module and delay the store substitution (substitute 'getStore[state] by STRInit in the state))
                                                                                *** TODO: Change Current program by P (symbolic program) - done
                                                                                (crl '`[_`]`[_`]`[_`]`[_`]`[_/_`][T1, '_`{_`}<`{_`}[stateVar(StateOp), 'Constraints:Boolean, 'Path:Path], 'N:Nat, 'STRInit:Map`{Var`,Value`}, 'LDepth:Nat, 'LBound:Bound]
                                                                                    =>
                                                                                    '`[_`]`[_`]`[_`]`[_`]`[_/_`][subT('updateProgram[T2, 'getProgram[stateVar(StateOp)]], 'STR:Map`{Var`,Value`}, 'init-CStore['STRInit:Map`{Var`,Value`}, 'Constraints':Boolean]),
                                                                                                                 '_`{_`}<`{_`}['updateStore[stateVar(StateOp), 'STRInit:Map`{Var`,Value`}], 'Constraints':Boolean, 'nil.Path], '_+_['N:Nat, 's_['0.Nat]], 'STRInit:Map`{Var`,Value`}, '0.Nat, 'LBound:Bound]
                                                                                    if 'metaCheck[upTerm(M), 'upTerm['evalB[Tcond]]] = 'true.Bool
                                                                                    /\ 'Constraints':Boolean := '_and_['Constraints:Boolean, 'evalB['not_[subT(Tcond, 'STR:Map`{Var`,Value`}, 'getStore[stateVar(StateOp)])]]]
                                                                                    /\ 'metaCheck[upTerm(M), 'upTerm['Constraints':Boolean]] = 'true.Bool
                                                                                [label(qid(string(InstId) + "-bis")) AttrSet] .)
                                                                                rlToConcolic(RlSet, StateOp, M)
        if (Tcond = 'val['true.Bool]) := Cond .

    op modSEImports : ImportList -> ImportList .
    eq modSEImports(nil) = nil .
    eq modSEImports((protecting 'CONCRETE-AEXP-MOD .) ImportList) = (protecting 'SMT-AEXP-MOD .) ImportList .
    eq modSEImports(Import ImportList) = Import modSEImports(ImportList) [owise] .

    op inclSEImports : ImportList -> ImportList .
    eq inclSEImports(ImportList) = modSEImports(ImportList)
                                   (protecting 'REAL-INTEGER .)
                                   (protecting 'META-LEVEL .)
                                   (protecting 'SMT-CONNECTION .)
                                   (protecting 'SE-LOCS-MOD .)
                                   (protecting 'LIST{'Location} * (sort 'List`{Location`} to 'Path) .) .
                                   ***(protecting 'LIST{'PairVarValue} .)
                                   ***(protecting 'LIST{'Inst} * (sort 'List`{Inst`} to 'Program) .)

    op inclSESorts : SortSet -> SortSet .
    eq inclSESorts(SortSet) = SortSet ; 'SEState ; 'ConstrainedStart ;
                              'ConcolicState ; 'ConcolicStateCore . ***; 'Location    

    ***op updateStateSymb : OpDeclSet Qid -> OpDeclSet .
    ***eq updateStateSymb((op 'start : 'Program -> StateOp .) OpDeclSet, StateOp)
    
    op toSMTSorts : TypeList -> TypeList .
    eq toSMTSorts(nil) = nil .
    eq toSMTSorts('Bool TL) = 'Boolean toSMTSorts(TL) .
    eq toSMTSorts('Int TL) = 'Integer toSMTSorts(TL) .
    eq toSMTSorts('Rat TL) = 'Real toSMTSorts(TL) .
    eq toSMTSorts(T TL) = T toSMTSorts(TL) [owise] .

    ***op modSESubsorts : SubsortDeclSet -> SubsortDeclSet .
    ***eq modSESubsorts(none) = none .
    ***eq modSESubsorts((subsort S1 < S2 .) SubsortDeclSet) = (subsort toSMTSorts(S1) < toSMTSorts(S2) .) modSESubsorts(SubsortDeclSet) .

    *** Old definition for transformation of value constructor
    op useSMTsorts : OpDeclSet Qid -> OpDeclSet .
    eq useSMTsorts(none, ValOp) = none .
    eq useSMTsorts((op ValOp : TL -> T [AttrSet] .) OpDeclSet, ValOp) = (op ValOp : toSMTSorts(TL) -> T [AttrSet] .)
                                                                        useSMTsorts(OpDeclSet, ValOp) . 
    eq useSMTsorts((op OpId : TL -> T [AttrSet] .) OpDeclSet, ValOp) = (op OpId : TL -> T [AttrSet] .) 
                                                                       useSMTsorts(OpDeclSet, ValOp) [owise] .

    *** Define the Symbolic State on top of the casual (concrete) state
    op modSEOps : OpDeclSet Qid Qid -> OpDeclSet .
    eq modSEOps(OpDeclSet, StateOp, ValOp) = OpDeclSet ***useSMTsorts(OpDeclSet, ValOp)
                                             (op '_`{_`}<`{_`} : StateOp 'Boolean 'Path -> 'SEState [ctor] .)
                                             (op '_where_ : 'Program 'Boolean -> 'ConstrainedStart [ctor] .)
                                             ***(op 'evalB : 'BExp -> 'Boolean [none] .)
                                             (op '`[_`]`[_`]`[_`]`[_`]`[_/_`] : StateOp 'SEState 'Int 'Map`{Var`,Value`} 'Nat 'Bound -> 'ConcolicState [ctor] .)
                                             ***(op '_`[_`]`[_/_`] : 'ConcolicStateCore 'Map`{Var`,Value`} 'Nat 'Bound -> 'ConcolicState [ctor] .)
                                             (op 'init-CStore : 'Map`{Var`,Value`} 'Boolean -> 'Map`{Var`,Value`} [none] .)
                                             (op '$apply-SMTassignment : 'Map`{Var`,Value`} 'AssignmentSMT -> 'Map`{Var`,Value`} [none] .) .
                                             ***(op 'size : 'Boolean -> 'Nat [none] .)
                                             ***(op 'start : 'Program 'List`{PairVarValue`} -> 'SEState [none] .)
                                             ***(op 'start : 'ConstrainedStart 'List`{PairVarValue`} -> 'SEState [none] .)
                                             ***(op '$start : StateOp 'List`{PairVarValue`} 'Map`{Var`,Value`} 'Boolean -> 'SEState [none] .)
                                             
                                             ***(op 'start : 'ConstrainedStart -> 'SEState [none] .)
                                             ***(op 'start : 'ConstrainedStart 'Program -> 'SEState [none] .)

    op modSEOpIds : Qid -> Qid .
    eq modSEOpIds('_==_) = '_===_ .
    eq modSEOpIds('_=/=_) = '_=/==_ . 
    eq modSEOpIds('_quo_) = '_div_ . 
    eq modSEOpIds(Q) = Q [owise] .

    op subSEVarSorts : Variable -> Variable .
    eq subSEVarSorts(MVar) = qid(string(getName(MVar)) + ":" + string(toSMTSorts(getType(MVar)))) .

    op subSEConstSorts : Constant -> Constant .
    eq subSEConstSorts(MConst) = qid(string(getName(MConst)) + "." + string(toSMTSorts(getType(MConst)))) .

    *** Substitute all Vars and Conts in Term
    op searchSubVarConst : TermList -> TermList .
    eq searchSubVarConst(empty) = empty .
    eq searchSubVarConst(MConst) = subSEConstSorts(MConst) .
    eq searchSubVarConst(MVar) = subSEVarSorts(MVar) .
    eq searchSubVarConst(OpId[T1]) = modSEOpIds(OpId)[searchSubVarConst(T1)] .
    eq searchSubVarConst(OpId[T1, NeTL]) = modSEOpIds(OpId)[searchSubVarConst(T1), searchSubVarConst(NeTL)] .
    eq searchSubVarConst((T1, NeTL)) = searchSubVarConst(T1), searchSubVarConst(NeTL) .

    *** Don't change Vars and Consts sorts but keep searching for Vals
    op subSETerm : Term Qid -> Term .
    eq subSETerm(MConst, ValOp) = MConst .
    eq subSETerm(MVar, ValOp) = MVar .
    eq subSETerm(OpId[T1], ValOp) = OpId[subSEVal(T1, ValOp)] .
    eq subSETerm(OpId[T1, NeTL], ValOp) = OpId[subSEVal(T1, ValOp), subSETermL(NeTL, ValOp)] .

    *** If Term is Val substitute all maude types by smt types, else keep searching for Vals
    op subSEVal : Term Qid -> Term .
    eq subSEVal(ValOp[TermL], ValOp) = ValOp[searchSubVarConst(TermL)] .
    eq subSEVal(T1, ValOp) = subSETerm(T1, ValOp) [owise] .

    *** Search for Vals in TermList
    op subSETermL : TermList Qid -> TermList .
    eq subSETermL(empty, ValOp) = empty .
    eq subSETermL(T1, ValOp) = subSEVal(T1, ValOp) .
    eq subSETermL((T1, NeTL), ValOp) = subSEVal(T1, ValOp), subSETermL(NeTL, ValOp) .


    op modSEEqs : EquationSet Qid -> EquationSet .
    eq modSEEqs(none, ValOp) = none .
    eq modSEEqs(eq T1 = T2 [AttrSet] . EquationSet, ValOp) = eq subSETermL(T1, ValOp) = subSETermL(T2, ValOp) [AttrSet] .
                                                             modSEEqs(EquationSet, ValOp) .
    
    op inclSEEqs : Qid -> EquationSet .
    eq inclSEEqs(StateOp) = (eq 'evalB['val['B:Boolean]] = 'B:Boolean [none] .)
                            (eq 'init-CStore['STR:Map`{Var`,Value`}, 'Constraints:Boolean] = '$apply-SMTassignment['STR:Map`{Var`,Value`}, 'get-SMTassignment['Constraints:Boolean]] [none] .)
                            (eq '$apply-SMTassignment['_`,_['_|->_['Var:Var, 'val['R:Real]], 'STR:Map`{Var`,Value`}], '_<--_['R:Real, 'Rconc:Real]] = '_`,_['_|->_['Var:Var, 'val['Rconc:Real]], 'STR:Map`{Var`,Value`}] [none] .)
                            (eq '$apply-SMTassignment['_`,_['_|->_['Var:Var, 'val['R:Real]], 'STR:Map`{Var`,Value`}], '_`,_['_<--_['R:Real, 'Rconc:Real], 'AssignmentSMT:AssignmentSMT]] = '_`,_['_|->_['Var:Var, 'val['Rconc:Real]], '$apply-SMTassignment['STR:Map`{Var`,Value`}, 'AssignmentSMT:AssignmentSMT]] [none] .)
                            (eq '$apply-SMTassignment['_`,_['_|->_['Var:Var, 'val['I:Integer]], 'STR:Map`{Var`,Value`}], '_<--_['I:Integer, 'Iconc:Integer]] = '_`,_['_|->_['Var:Var, 'val['Iconc:Integer]], 'STR:Map`{Var`,Value`}] [none] .)
                            (eq '$apply-SMTassignment['_`,_['_|->_['Var:Var, 'val['I:Integer]], 'STR:Map`{Var`,Value`}], '_`,_['_<--_['I:Integer, 'Iconc:Integer], 'AssignmentSMT:AssignmentSMT]] = '_`,_['_|->_['Var:Var, 'val['Iconc:Integer]], '$apply-SMTassignment['STR:Map`{Var`,Value`}, 'AssignmentSMT:AssignmentSMT]] [none] .)
                            (eq '$apply-SMTassignment['STR:Map`{Var`,Value`}, 'failed.AssignmentSMT] = 'STR:Map`{Var`,Value`} [none] .) .
                            ***(eq 'size['C1:Boolean] = ''s_['0.Nat] [none] .)
                            ***(eq 'size['_and_['C1:Boolean, 'Constraints:Boolean]] = ''s_['0.Nat] + 'size['Constraints:Boolean] [none] .)
                            ***(eq 'start['P:Program, 'SVDeclL:List`{PairVarValue`}] = '$start['start['P:Program], 'SVDeclL:List`{PairVarValue`}, 'empty.Map`{Var`,Value`}, 'true.Boolean] [none] .)
                            ***(eq 'start['_where_['P:Program, 'B:Boolean, 'SVDeclL:List`{PairVarValue`}]] = '$start['start['P:Program], 'SVDeclL:List`{PairVarValue`}, 'empty.Map`{Var`,Value`}, 'B:Boolean] [none] .)
                            ***(eq '$start[stateVar(StateOp), nil, 'STR:Map`{Var`,Value`}, 'B:Boolean] = '_`{_`}<`{_`}['updateStore[stateVar(StateOp), 'STR:Map`{Var`,Value`}], 'B:Boolean, 'nil.Path] [none] .)
                            ***(eq '$start[stateVar(StateOp), '__['_`,_['Var:Var, 'V:Value], 'SVDeclL:List`{PairVarValue`}], 'STR:Map`{Var`,Value`}, 'B:Boolean] = '$start[stateVar(StateOp), 'SVDeclL:List`{PairVarValue`}, 'insert['Var:Var, 'V:Value, 'STR:Map`{Var`,Value`}], 'B:Boolean] [none] .)

    ***op transformModSymb : Module Qid Qid -> Module .
    ***op transformModSymb : Module Qid Qid Qid Qid Qid -> Module .
    ***eq transformModSymb(M, StateOp, ValOp) = modRl(mod 'PARTIAL-SYMBOLIC-MOD is
    ***                                            inclSEImports(getImports(M))
    ***                                            sorts inclSESorts(getSorts(M)) .
    ***                                            getSubsorts(M)
    ***                                            modSEOps(getOps(M), StateOp, ValOp)
    ***                                            getMbs(M)
    ***                                            modSEEqs(getEqs(M), ValOp) inclSEEqs(StateOp)
    ***                                            getRls(M)
    ***                                         endm) .
    op transformModSymb : QidList Qid Qid Qid -> Module .
    op transformModSymb : QidList Qid Qid Qid Module -> Module .
    eq transformModSymb(ModIdList, StateOp, ValOp, TrId) = transformModSymb(ModIdList, StateOp, ValOp, TrId, mod 'SEMANTICS is nil sorts none . none none none none none endm) .
    eq transformModSymb(nil, StateOp, ValOp, TrId, M) = modRl(mod 'PARTIAL-SYMBOLIC-MOD is
                                                                inclSEImports(getImports(M))
                                                                sorts inclSESorts(getSorts(M)) .
                                                                getSubsorts(M)
                                                                modSEOps(getOps(M), StateOp, ValOp)
                                                                getMbs(M)
                                                                modSEEqs(getEqs(M), ValOp) inclSEEqs(StateOp)
                                                                getRls(M)
                                                              endm, StateOp, TrId) .
    ceq transformModSymb(ModId ModIdList, StateOp, ValOp, TrId, AccM) = transformModSymb(ModIdList, StateOp, ValOp, TrId,
                                                                        mod getName(AccM) is
                                                                            getImports(M) getImports(AccM)
                                                                            sorts getSorts(M) ; getSorts(AccM) .
                                                                            getSubsorts(M) getSubsorts(AccM)
                                                                            getOps(M) getOps(AccM)
                                                                            getMbs(M) getMbs(AccM)
                                                                            getEqs(M) getEqs(AccM)
                                                                            getRls(M) getRls(AccM)
                                                                        endm)
        if M := upModule(ModId, false) .

    ***eq 'pr = 'protecting .

endfm

mod VERIFICATION-COMMANDS is

    pr MODULE-TRANSFORMER .
    pr LEXICAL .

    vars ModId StateOp SearchType ValOp TrId TargetSt : Qid .
    var PatternSEState : Term .
    var InitSEState : String . 
    var SearchCond : Condition .
    var Bound : Bound .
    var SolN : Nat .
    var ModIdList : QidList .
    var NeModIdList : NeQidList .

    op searchTr : NeQidList Qid Qid Qid Qid String Term Condition Qid Bound Nat -> ResultTriple .
    eq searchTr(ModId, StateOp, ValOp, TrId, TargetSt,
                  InitSEState,
                  PatternSEState,
                  SearchCond,
                  SearchType,
                  Bound,
                  SolN)
                  =
                  metaSearch(transformModSymb(ModId, StateOp, ValOp, TrId, mod 'SEMANTICS is nil sorts none . none none none none none endm),
                             getTerm(metaParse(transformModSymb(ModId, StateOp, ValOp, TrId, mod 'SEMANTICS is nil sorts none . none none none none none endm),
                                               tokenize(InitSEState), TargetSt)),
                             PatternSEState,
                             SearchCond,
                             SearchType,
                             Bound,
                             SolN) .
    eq searchTr(ModId NeModIdList, StateOp, ValOp, TrId, TargetSt,
                  InitSEState,
                  PatternSEState,
                  SearchCond,
                  SearchType,
                  Bound,
                  SolN)
                  =
                  metaSearch(transformModSymb(ModId NeModIdList, StateOp, ValOp, TrId, mod 'SEMANTICS is nil sorts none . none none none none none endm),
                             getTerm(metaParse(transformModSymb(ModId NeModIdList, StateOp, ValOp, TrId, mod 'SEMANTICS is nil sorts none . none none none none none endm),
                                               tokenize(InitSEState), TargetSt)),
                             PatternSEState,
                             SearchCond,
                             SearchType,
                             Bound,
                             SolN) .
    
    op searchSymb : NeQidList Qid Qid String Term Condition Qid Bound Nat -> ResultTriple .
    eq searchSymb(ModId NeModIdList, StateOp, ValOp,
                  InitSEState,
                  PatternSEState,
                  SearchCond,
                  SearchType,
                  Bound,
                  SolN)
                  = searchTr(ModId NeModIdList, StateOp, ValOp, 'symb, 'SEState,
                        InitSEState,
                        PatternSEState,
                        SearchCond,
                        SearchType,
                        Bound,
                        SolN) .

    op searchConcolic : NeQidList Qid Qid String Term Condition Qid Bound Nat -> ResultTriple .
    eq searchConcolic(ModId NeModIdList, StateOp, ValOp,
                      InitSEState,
                      PatternSEState,
                      SearchCond,
                      SearchType,
                      Bound,
                      SolN)
                      = searchTr(ModId NeModIdList, StateOp, ValOp, 'conc, 'ConcolicState,
                                 InitSEState,
                                 PatternSEState,
                                 SearchCond,
                                 SearchType,
                                 Bound,
                                 SolN) .

endm
