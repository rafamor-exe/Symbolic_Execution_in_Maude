load semantics-basics/semantics-basics-smtTypes.maude

*** Test transformer with while language module
***load language-semantics/while-semantics-concrete.maude
***set trace on .

fmod SE-LOCS-MOD is
    protecting QID .
    sort Location .
    op loc : Qid -> Location [ctor] .
endfm

view Location from TRIV to SE-LOCS-MOD is
  sort Elt to Location .
endv

fmod SMT-CONNECTION is
    pr REAL-INTEGER .
    pr SMT-CONVERSION .
    pr SE-LOCS-MOD .
    pr LIST{Location} * (sort List{Location} to Path) .
    pr LIST{PairVarValue} .

    sort AssignmentSMT .

    op _<--_ : Real Real -> AssignmentSMT [ctor] . *** test syntax
    op _<--_ : Integer Integer -> AssignmentSMT [ctor] . *** test syntax
    op _,_ : AssignmentSMT AssignmentSMT -> AssignmentSMT .
    op failed : -> AssignmentSMT [ctor] .

    op get-SMTassignment : Boolean -> AssignmentSMT [special (id-hook SpecialHubSymbol)] .
endfm

fmod MODULE-TRANSFORMER is
    ***pr META-LEVEL .
    pr STRING-OPS .
    ***pr CONVERSION .
    pr SMT-CONNECTION .

    sort TrType .
    
    ops symb conc maudeSE clconc : -> TrType [ctor] .

    vars Trm T1 T2 Tcond Tmod Constraints Path : Term .
    var AttrSet : AttrSet .
    var RlSet : RuleSet .
    var Rule : Rule .
    var Cond : Condition .
    var Header : Header .
    var ImportList : ImportList .
    var SortSet : SortSet .
    var SubsortDeclSet : SubsortDeclSet .
    var OpDeclSet : OpDeclSet .
    var MembAxSet : MembAxSet .
    var EquationSet : EquationSet .
    vars InstId StateOp OpId ModId Q ValOp : Qid .
    var TrId : TrType .
    vars M M1 M2 AccM : Module .
    var FM : FModule .
    var TL : TypeList .
    var T : Type .
    var S1 S2 : Sort .
    var Import : Import .
    vars ModIdList QL : QidList .
    var TermL : TermList .
    var NeTL : NeTermList .
    var Smain S S' : String .
    var N? : FindResult .
    var MVar : Variable .
    var MConst : Constant .
    var B : Bool .
    var N : Nat .
    var I : Integer .

    op modRl : Module Qid TrType -> Module .
    op modRl : Module TrType -> Module .
    eq modRl(M, StateOp, symb) = mod 'SYMBOLIC-MOD is
                                    getImports(M)
                                    sorts getSorts(M) .
                                    getSubsorts(M)
                                    getOps(M)
                                    getMbs(M)
                                    getEqs(M)
                                    rlToSymbolic(getRls(M))
                                  endm .
    eq modRl(M, StateOp, conc) = mod 'CONCOLIC-MOD is
                                    getImports(M)
                                    sorts getSorts(M) .
                                    getSubsorts(M)
                                    getOps(M)
                                    getMbs(M)
                                    getEqs(M)
                                    rlToConcolic(getRls(M), StateOp)
                                  endm .
    
    eq modRl(M, StateOp, maudeSE) = M .

    eq modRl(M, StateOp, clconc) = mod 'CONCOLIC-MOD is
                                    getImports(M)
                                    sorts getSorts(M) .
                                    getSubsorts(M)
                                    getOps(M)
                                    getMbs(M)
                                    getEqs(M)
                                    rlToClConcolic(getRls(M), StateOp) inclClConcCrl(StateOp)
                                   endm .
    
    *** Generic Term substitution: substitute T1 by T2 in Trm
    op subT : Term Term Term -> Term .
    eq subT(MConst, MConst, T2) = T2 .
    eq subT(MVar, MVar, T2) = T2 .
    eq subT(OpId[Trm], T1, T2) = OpId[subT(Trm, T1, T2)] .
    eq subT(OpId[Trm, NeTL], T1, T2) = OpId[subT(Trm, T1, T2), subTL(NeTL, T1, T2)] .
    eq subT(Trm, T1, T2) = Trm [owise] .

    op subTL : TermList Term Term -> Term .
    eq subTL(empty, T1, T2) = empty .
    eq subTL(Trm, T1, T2) = subT(Trm, T1, T2) .
    eq subTL((Trm, NeTL), T1, T2) = subT(Trm, T1, T2), subTL(NeTL, T1, T2) .


    op rlToSymbolic : RuleSet -> RuleSet .
    eq rlToSymbolic(none) = none .
    eq rlToSymbolic(rl T1 => T2 [label(InstId) AttrSet] . RlSet) = rl '_`{_`}<`{_`}[T1, 'Constraints:Boolean, 'Path:Path] => '_`{_`}<`{_`}[T2, 'Constraints:Boolean, '__['Path:Path, 'loc[upTerm(InstId)]]] [label(InstId) AttrSet] . rlToSymbolic(RlSet) .
    *** TODO: parametrize language-specific sorts (Map, BExp)
    ceq rlToSymbolic(crl T1 => T2 if Cond [label(InstId) AttrSet] . RlSet) = crl '_`{_`}<`{_`}[T1, 'Constraints:Boolean, 'Path:Path] => '_`{_`}<`{_`}[T2, 'Constraints:Boolean, '__['Path:Path, 'loc[upTerm(InstId)]]] if 'Constraints':Boolean := '_and_['Constraints:Boolean, Tcond] /\ 'metaCheck[upTerm(upModule('REAL-INTEGER, false)), 'upTerm['Constraints':Boolean]] = 'true.Bool [label(InstId) AttrSet] . rlToSymbolic(RlSet)
        if (Tcond = 'true.Boolean) := Cond .
    
    *** State var general definition
    op stateVar : Qid -> Variable .
    eq stateVar(StateOp) = qid(string('State) + ":" + string(StateOp)) .
    op stateVar : Qid Nat -> Variable .
    eq stateVar(StateOp, N) = qid(string('State) + string(N, 10) + ":" + string(StateOp)) .

    op symbState : Qid -> Term .
    eq symbState(StateOp) = '_`{_`}<`{_`}[stateVar(StateOp), 'Constraints:Boolean, 'Path:Path] .
    op symbState : Qid Nat -> Term .
    eq symbState(StateOp, N) = '_`{_`}<`{_`}[stateVar(StateOp, N), 'Constraints:Boolean, 'Path:Path] .

    op concolicState : Qid -> Term .
    eq concolicState(StateOp) = '`[_`]`[_`]`[_`]`[_`][stateVar(StateOp, 0), symbState(StateOp, 1), 'N:Nat, 'STRInit:Map`{Var`,Value`}] .
    op concolicState : Qid Term -> Term .
    eq concolicState(StateOp, T1) = '`[_`]`[_`]`[_`]`[_`][T1, symbState(StateOp, 1), 'N:Nat, 'STRInit:Map`{Var`,Value`}] .

    op rlToConcolic : RuleSet Qid -> RuleSet .
    eq rlToConcolic(none, StateOp) = none .
    *** Symbolic rules must not be applied to internal symbolic state during concolic exec
    *** These rules cannot be merged into one with 'if_then_else_fi because that distinction should be done at this level (transformation), not delayed
    eq rlToConcolic(rl T1 => T2 [label(InstId) AttrSet] . RlSet, StateOp) = ***(crl '`[_`]`[_`]`[_`]`[_`][T1, '_`{_`}<`{_`}[stateVar(StateOp), 'Constraints:Boolean, 'Path:Path], 'N:Nat, 'STRInit:Map`{Var`,Value`}]
                                                                               ***=>
                                                                               ***'`[_`]`[_`]`[_`]`[_`][T2, '_`{_`}<`{_`}[stateVar(StateOp), 'Constraints:Boolean, '__['Path:Path, 'loc[upTerm(InstId)]]], 'N:Nat, 'STRInit:Map`{Var`,Value`}]
                                                                               ***if '_==_['getStore[T1], 'getStore[T2]] = 'true.Bool
                                                                               ***[label(InstId) AttrSet] .)
                                                                               *** if the store is not the same update it in the symb state using the same mechanism as in the original rl but over the symb store
                                                                               (rl '`[_`]`[_`]`[_`]`[_`][T1, '_`{_`}<`{_`}[stateVar(StateOp), 'Constraints:Boolean, 'Path:Path], 'N:Nat, 'STRInit:Map`{Var`,Value`}]
                                                                               =>
                                                                               '`[_`]`[_`]`[_`]`[_`][T2, '_`{_`}<`{_`}[subT('updateProgram[T2, 'getProgram[stateVar(StateOp)]], 'STR:Map`{Var`,Value`}, 'getStore[stateVar(StateOp)]), 'Constraints:Boolean, '__['Path:Path, 'loc[upTerm(InstId)]]], 'N:Nat, 'STRInit:Map`{Var`,Value`}]
                                                                               ***if '_=/=_['getStore[T1], 'getStore[T2]] = 'true.Bool
                                                                               ***if 'insert['Var:Var, 'Val:Value, 'STR:Map`{Var`,Value`}] := 'getStore[T2]
                                                                               ***[label(qid(string(InstId) + "-bis")) AttrSet] .)
                                                                               [label(InstId) AttrSet] .)
                                                                               rlToConcolic(RlSet, StateOp) .
    ***eq rlToConcolic(rl T1 => T2 [label(InstId) AttrSet] . RlSet, StateOp, M) = crl '`[_`]`[_`]`[_`]`[_`][T1, '_`{_`}<`{_`}[stateVar(StateOp), 'Constraints:Boolean, 'Path:Path], 'N:Nat, 'STRInit:Map`{Var`,Value`}]
    ***                                                                           =>
    ***                                                                           '`[_`]`[_`]`[_`]`[_`][T2, '_`{_`}<`{_`}['insertToSt[stateVar(StateOp), 'Var:Var, 'Val:Value], 'Constraints:Boolean, '__['Path:Path, 'loc[upTerm(InstId)]]], 'N:Nat, 'STRInit:Map`{Var`,Value`}]
    ***                                                                           if 'insert['Var:Var, 'Val:Value, 'STR:Map`{Var`,Value`}] := 'getStore[T2]
    ***                                                                           [label(InstId) AttrSet] .
    ***                                                                           rlToConcolic(RlSet, StateOp, M) .
    
    *** TODO: Generalize hardcoded STR variable indicating the concrete store
    ceq rlToConcolic(crl T1 => T2 if Cond [label(InstId) AttrSet] . RlSet, StateOp) = (crl '`[_`]`[_`]`[_`]`[_`][T1, '_`{_`}<`{_`}[stateVar(StateOp), 'Constraints:Boolean, 'Path:Path], 'N:Nat, 'STRInit:Map`{Var`,Value`}]
                                                                                          =>
                                                                                          '`[_`]`[_`]`[_`]`[_`][T2, '_`{_`}<`{_`}[subT('updateProgram[T2, 'getProgram[stateVar(StateOp)]], 'STR:Map`{Var`,Value`}, 'getStore[stateVar(StateOp)]), 'Constraints':Boolean, '__['Path:Path, 'loc[upTerm(InstId)]]], 'N:Nat, 'STRInit:Map`{Var`,Value`}]
                                                                                          if 'Constraints':Boolean := '_and_['Constraints:Boolean, subT(Tcond, 'STR:Map`{Var`,Value`}, 'getStore[stateVar(StateOp)])]
                                                                                          /\ 'metaCheck[upTerm(upModule('REAL-INTEGER, false)), 'upTerm[Tcond]] = 'true.Bool
                                                                                          [label(InstId) AttrSet] .)
                                                                                      (crl '`[_`]`[_`]`[_`]`[_`][T1, '_`{_`}<`{_`}[stateVar(StateOp), 'Constraints:Boolean, 'Path:Path], 'N:Nat, 'STRInit:Map`{Var`,Value`}]
                                                                                          =>
                                                                                          '`[_`]`[_`]`[_`]`[_`][subT('updateProgram[T2, 'getProgram[stateVar(StateOp)]], 'STR:Map`{Var`,Value`}, 'init-CStore['STRInit:Map`{Var`,Value`}, 'Constraints':Boolean]),
                                                                                                                      '_`{_`}<`{_`}['updateStore[stateVar(StateOp), 'STRInit:Map`{Var`,Value`}], 'Constraints':Boolean, 'nil.Path], '_+_['N:Nat, 's_['0.Nat]], 'STRInit:Map`{Var`,Value`}]
                                                                                          if 'metaCheck[upTerm(upModule('REAL-INTEGER, false)), 'upTerm[Tcond]] = 'true.Bool
                                                                                          /\ 'Constraints':Boolean := '_and_['Constraints:Boolean, 'not_[subT(Tcond, 'STR:Map`{Var`,Value`}, 'getStore[stateVar(StateOp)])]]
                                                                                          /\ 'metaCheck[upTerm(upModule('REAL-INTEGER, false)), 'upTerm['Constraints':Boolean]] = 'true.Bool
                                                                                          [label(qid(string(InstId) + "-bis")) AttrSet] .)
                                                                                          rlToConcolic(RlSet, StateOp)
        if (Tcond = 'true.Boolean) := Cond .

    op rlToClConcolic : RuleSet Qid -> RuleSet .
    eq rlToClConcolic(none, StateOp) = none .
    eq rlToClConcolic(rl T1 => T2 [AttrSet] . RlSet, StateOp) = rlToConcolic(rl T1 => T2 [AttrSet] . RlSet, StateOp)
                                                                   rlToClConcolic(RlSet, StateOp) .
    ceq rlToClConcolic(crl T1 => T2 if Cond [label(InstId) AttrSet] . RlSet, StateOp) = (crl '`[_`]`[_`]`[_`]`[_`][T1, '_`{_`}<`{_`}[stateVar(StateOp), 'Constraints:Boolean, 'Path:Path], 'N:Nat, 'STRInit:Map`{Var`,Value`}]
                                                                                          =>
                                                                                          '`[_`]`[_`]`[_`]`[_`][T2, '_`{_`}<`{_`}[stateVar(StateOp), 'Constraints':Boolean, '__['Path:Path, 'loc[upTerm(InstId)]]], 'N:Nat, 'STRInit:Map`{Var`,Value`}]
                                                                                          if 'Constraints':Boolean := '_and_['Constraints:Boolean, subT(Tcond, 'STR:Map`{Var`,Value`}, 'getStore[stateVar(StateOp)])]
                                                                                          /\ 'metaCheck[upTerm(upModule('REAL-INTEGER, false)), 'upTerm[Tcond]] = 'true.Bool
                                                                                          [label(InstId) AttrSet] .)
                                                                                          rlToConcolic(RlSet, StateOp)
        if (Tcond = 'true.Boolean) := Cond .
    
    op inclClConcCrl : Qid -> RuleSet .
    ***eq inclClConcCrl(StateOp) = (crl '`[_`]`[_`]`[_`]`[_`][T1, '_`{_`}<`{_`}[stateVar(StateOp), 'Constraints:Boolean, 'Path:Path], 'N:Nat, 'STRInit:Map`{Var`,Value`}]
    ***                                =>
    ***                                '`[_`]`[_`]`[_`]`[_`][subT('updateProgram[T2, 'getProgram[stateVar(StateOp)]], 'STR:Map`{Var`,Value`}, 'init-CStore['STRInit:Map`{Var`,Value`}, 'Constraints':Boolean]),
    ***                                                            '_`{_`}<`{_`}['updateStore[stateVar(StateOp), 'STRInit:Map`{Var`,Value`}], 'Constraints':Boolean, 'nil.Path], '_+_['N:Nat, 's_['0.Nat]], 'STRInit:Map`{Var`,Value`}]
    ***                                if 'metaCheck[upTerm(upModule('REAL-INTEGER, false)), 'upTerm['Constraints:Boolean]] = 'true.Bool
    ***                                [label(qid("re-exec")) AttrSet] .)
    
    ***op rlToMaudeSE : RuleSet Module -> RuleSet .
    ***eq rlToMaudeSE(none, M) = none .
    ***ceq rlToMaudeSE(crl T1 => T2 if Cond [label(InstId) AttrSet] . RlSet, M) = (crl T1 => T2 
    ***                                                                            if Tcond = 'true.Boolean 
    ***                                                                            [label(InstId) AttrSet] .)
    ***                                                                           rlToMaudeSE(RlSet, M)
    ***    if (Tcond = 'true.Boolean) := Cond .
    ***eq rlToMaudeSE(Rule RlSet, M) = Rule rlToMaudeSE(RlSet, M) [owise] .

    op modSEImports : ImportList -> ImportList .
    eq modSEImports(ImportList) = ImportList .
    ***eq modSEImports(nil) = nil .
    ***eq modSEImports((protecting 'CONCRETE-AEXP-MOD .) ImportList) = (protecting 'SMT-AEXP-MOD .) ImportList .
    ***eq modSEImports(Import ImportList) = Import modSEImports(ImportList) [owise] .

    op inclSEImports : ImportList -> ImportList .
    eq inclSEImports(ImportList) = ImportList ***modSEImports(ImportList)
                                   ***(protecting 'REAL-INTEGER .)
                                   ***(protecting 'META-LEVEL .)
                                   ***(protecting 'SMT-CONNECTION .)
                                   ***(protecting 'SE-LOCS-MOD .)
                                   ***(protecting 'LIST{'Location} * (sort 'List`{Location`} to 'Path) .) .
                                   ***(protecting 'LIST{'PairVarValue} .)
                                   ***(protecting 'LIST{'Inst} * (sort 'List`{Inst`} to 'Program) .)

    op inclSESorts : SortSet -> SortSet .
    eq inclSESorts(SortSet) = SortSet ; 'SEState ; 'ConstrainedStart ;
                              'ConcolicState ; 'ConcolicStateCore . ***; 'Location    

    ***op updateStateSymb : OpDeclSet Qid -> OpDeclSet .
    ***eq updateStateSymb((op 'start : 'Program -> StateOp .) OpDeclSet, StateOp)
    
    op toSMTSorts : TypeList -> TypeList .
    eq toSMTSorts(nil) = nil .
    eq toSMTSorts('Bool TL) = 'Boolean toSMTSorts(TL) .
    eq toSMTSorts('Int TL) = 'Integer toSMTSorts(TL) .
    eq toSMTSorts('Rat TL) = 'Real toSMTSorts(TL) .
    eq toSMTSorts('Zero TL) = 'Integer toSMTSorts(TL) .
    eq toSMTSorts(T TL) = T toSMTSorts(TL) [owise] .

    ***op modSESubsorts : SubsortDeclSet -> SubsortDeclSet .
    ***eq modSESubsorts(none) = none .
    ***eq modSESubsorts((subsort S1 < S2 .) SubsortDeclSet) = (subsort toSMTSorts(S1) < toSMTSorts(S2) .) modSESubsorts(SubsortDeclSet) .

    *** Old definition for transformation of value constructor
    op useSMTsorts : OpDeclSet Qid -> OpDeclSet .
    eq useSMTsorts(none, ValOp) = none .
    eq useSMTsorts((op ValOp : TL -> T [AttrSet] .) OpDeclSet, ValOp) = (op ValOp : toSMTSorts(TL) -> T [AttrSet] .)
                                                                        useSMTsorts(OpDeclSet, ValOp) . 
    eq useSMTsorts((op 'eval : TL -> T [AttrSet] .) OpDeclSet, ValOp) = (op 'eval : TL -> toSMTSorts(T) [AttrSet] .)
                                                                        useSMTsorts(OpDeclSet, ValOp) . 
    eq useSMTsorts((op OpId : TL -> T [AttrSet] .) OpDeclSet, ValOp) = (op OpId : TL -> T [AttrSet] .) 
                                                                       useSMTsorts(OpDeclSet, ValOp) [owise] .

    *** Define the Symbolic State on top of the casual (concrete) state
    op modSEOps : OpDeclSet Qid Qid -> OpDeclSet .
    eq modSEOps(OpDeclSet, StateOp, ValOp) = useSMTsorts(OpDeclSet, ValOp) ***OpDeclSet
                                             (op '_`{_`}<`{_`} : StateOp 'Boolean 'Path -> 'SEState [ctor] .)
                                             (op '_where_ : StateOp 'Boolean -> 'ConstrainedStart [ctor] .)
                                             ***(op 'evalB : 'BExp -> 'Boolean [none] .)
                                             (op '`[_`]`[_`]`[_`]`[_`] : StateOp 'SEState 'Int 'Map`{Var`,Value`} -> 'ConcolicState [ctor] .)
                                             ***(op '_`[_`] : 'ConcolicStateCore 'Map`{Var`,Value`} -> 'ConcolicState [ctor] .)
                                             (op 'init-CStore : 'Map`{Var`,Value`} 'Boolean -> 'Map`{Var`,Value`} [none] .)
                                             (op '$apply-SMTassignment : 'Map`{Var`,Value`} 'AssignmentSMT -> 'Map`{Var`,Value`} [none] .)
                                             ***(op 'size : 'Boolean -> 'Nat [none] .)
                                             (op 'start : StateOp 'List`{PairVarValue`} -> 'ConcolicState [none] .)
                                             (op 'start : 'ConstrainedStart 'List`{PairVarValue`} -> 'ConcolicState [none] .)
                                             (op '$start : StateOp 'List`{PairVarValue`} 'Map`{Var`,Value`} 'Boolean -> 'ConcolicState [none] .)
                                             (op 'startSE : StateOp 'List`{PairVarValue`} 'Map`{Var`,Value`} -> StateOp [none] .) .
                                             
                                             ***(op 'start : 'ConstrainedStart -> 'SEState [none] .)
                                             ***(op 'start : 'ConstrainedStart 'Program -> 'SEState [none] .)

    op modSEOpIds : Qid -> Qid .
    eq modSEOpIds('_==_) = '_===_ .
    eq modSEOpIds('_=/=_) = '_=/==_ . 
    eq modSEOpIds('_quo_) = '_div_ . 
    eq modSEOpIds('rat) = 'toReal . 
    eq modSEOpIds(Q) = Q [owise] .

    op subSEVarSorts : Variable -> Variable .
    eq subSEVarSorts(MVar) = qid(string(getName(MVar)) + ":" + string(toSMTSorts(getType(MVar)))) .

    op subSEConstSorts : Constant -> Constant .
    eq subSEConstSorts(MConst) = qid(string(getName(MConst)) + "." + string(toSMTSorts(getType(MConst)))) .

    *** Substitute all Vars and Consts in TermList with SMT correspondence
    op searchSubVarConst : TermList -> TermList .
    eq searchSubVarConst(empty) = empty .
    eq searchSubVarConst(MConst) = subSEConstSorts(MConst) .
    eq searchSubVarConst(MVar) = subSEVarSorts(MVar) .
    eq searchSubVarConst(OpId[T1]) = modSEOpIds(OpId)[searchSubVarConst(T1)] .
    eq searchSubVarConst(OpId[T1, NeTL]) = modSEOpIds(OpId)[searchSubVarConst(T1), searchSubVarConst(NeTL)] .
    eq searchSubVarConst((T1, NeTL)) = searchSubVarConst(T1), searchSubVarConst(NeTL) .

    *** Don't change Vars and Consts sorts but keep searching for Vals
    op subSETerm : Term Qid -> Term .
    eq subSETerm(MConst, ValOp) = MConst .
    eq subSETerm(MVar, ValOp) = MVar .
    eq subSETerm(OpId[T1], ValOp) = OpId[subSEVal(T1, ValOp)] .
    eq subSETerm(OpId[T1, NeTL], ValOp) = OpId[subSEVal(T1, ValOp), subSETermL(NeTL, ValOp)] .

    *** If Term is Val substitute all maude types by smt types, else keep searching for Vals
    op subSEVal : Term Qid -> Term .
    eq subSEVal(ValOp[TermL], ValOp) = ValOp[searchSubVarConst(TermL)] .
    eq subSEVal(T1, ValOp) = subSETerm(T1, ValOp) [owise] .

    *** Search for Vals in TermList
    op subSETermL : TermList Qid -> TermList .
    eq subSETermL(empty, ValOp) = empty .
    eq subSETermL(T1, ValOp) = subSEVal(T1, ValOp) .
    eq subSETermL((T1, NeTL), ValOp) = subSEVal(T1, ValOp), subSETermL(NeTL, ValOp) .


    op modSEEqs : EquationSet Qid -> EquationSet .
    eq modSEEqs(none, ValOp) = none .
    eq modSEEqs(eq 'eval['val['B:Bool]] = 'B:Bool [AttrSet] . EquationSet, ValOp) = eq 'eval['val['B:Boolean]] = 'B:Boolean [AttrSet] . modSEEqs(EquationSet, ValOp) .
    eq modSEEqs(eq 'eval['val['B:Bool], 'STR:Map`{Var`,Value`}] = 'B:Bool [AttrSet] . EquationSet, ValOp) = eq 'eval['val['B:Boolean], 'STR:Map`{Var`,Value`}] = 'B:Boolean [AttrSet] . modSEEqs(EquationSet, ValOp) .
    eq modSEEqs(eq T1 = T2 [AttrSet] . EquationSet, ValOp) = eq subSETermL(T1, ValOp) = subSETermL(T2, ValOp) [AttrSet] .
                                                             modSEEqs(EquationSet, ValOp) [owise] .
    
    op inclSEEqs : Qid -> EquationSet .
    eq inclSEEqs(StateOp) = ***(eq 'evalB['val['B:Boolean]] = 'B:Boolean [none] .)
                            (eq 'init-CStore['STR:Map`{Var`,Value`}, 'Constraints:Boolean] = '$apply-SMTassignment['STR:Map`{Var`,Value`}, 'get-SMTassignment['Constraints:Boolean]] [none] .)
                            (eq '$apply-SMTassignment['_`,_['_|->_['Var:Var, 'val['R:Real]], 'STR:Map`{Var`,Value`}], '_<--_['R:Real, 'Rconc:Real]] = '_`,_['_|->_['Var:Var, 'val['Rconc:Real]], 'STR:Map`{Var`,Value`}] [none] .)
                            (eq '$apply-SMTassignment['_`,_['_|->_['Var:Var, 'val['R:Real]], 'STR:Map`{Var`,Value`}], '_`,_['_<--_['R:Real, 'Rconc:Real], 'AssignmentSMT:AssignmentSMT]] = '_`,_['_|->_['Var:Var, 'val['Rconc:Real]], '$apply-SMTassignment['STR:Map`{Var`,Value`}, 'AssignmentSMT:AssignmentSMT]] [none] .)
                            (eq '$apply-SMTassignment['_`,_['_|->_['Var:Var, 'val['I:Integer]], 'STR:Map`{Var`,Value`}], '_<--_['I:Integer, 'Iconc:Integer]] = '_`,_['_|->_['Var:Var, 'val['Iconc:Integer]], 'STR:Map`{Var`,Value`}] [none] .)
                            (eq '$apply-SMTassignment['_`,_['_|->_['Var:Var, 'val['I:Integer]], 'STR:Map`{Var`,Value`}], '_`,_['_<--_['I:Integer, 'Iconc:Integer], 'AssignmentSMT:AssignmentSMT]] = '_`,_['_|->_['Var:Var, 'val['Iconc:Integer]], '$apply-SMTassignment['STR:Map`{Var`,Value`}, 'AssignmentSMT:AssignmentSMT]] [none] .)
                            (eq '$apply-SMTassignment['STR:Map`{Var`,Value`}, 'failed.AssignmentSMT] = 'STR:Map`{Var`,Value`} [none] .)
                            (eq 'not_['not_['B:Boolean]] = 'B:Boolean [none] .)
                            ***(eq 'size['C1:Boolean] = ''s_['0.Nat] [none] .)
                            ***(eq 'size['_and_['C1:Boolean, 'Constraints:Boolean]] = ''s_['0.Nat] + 'size['Constraints:Boolean] [none] .)
                            (eq 'start[stateVar(StateOp), 'SVDeclL:List`{PairVarValue`}] = '$start[stateVar(StateOp), 'SVDeclL:List`{PairVarValue`}, 'empty.Map`{Var`,Value`}, 'true.Boolean] [none] .)
                            (eq 'start['_where_[stateVar(StateOp), 'B:Boolean], 'SVDeclL:List`{PairVarValue`}] = '$start[stateVar(StateOp), 'SVDeclL:List`{PairVarValue`}, 'empty.Map`{Var`,Value`}, 'B:Boolean] [none] .)
                            (eq '$start[stateVar(StateOp), 'nil.List`{PairVarValue`}, 'STR:Map`{Var`,Value`}, 'B:Boolean] = '`[_`]`[_`]`[_`]`[_`]['updateStore[stateVar(StateOp), 'init-CStore['STR:Map`{Var`,Value`}, 'B:Boolean]], '_`{_`}<`{_`}['updateStore[stateVar(StateOp), 'STR:Map`{Var`,Value`}], 'B:Boolean, 'nil.Path], '0.Nat, 'STR:Map`{Var`,Value`}] [none] .)
                            (eq '$start[stateVar(StateOp), '__['_`,_['Var:Var, 'V:Value], 'SVDeclL:List`{PairVarValue`}], 'STR:Map`{Var`,Value`}, 'B:Boolean] = '$start[stateVar(StateOp), 'SVDeclL:List`{PairVarValue`}, 'insert['Var:Var, 'V:Value, 'STR:Map`{Var`,Value`}], 'B:Boolean] [none] .)
                            (eq 'startSE[stateVar(StateOp), 'nil.List`{PairVarValue`}, 'STR:Map`{Var`,Value`}] = 'updateStore[stateVar(StateOp), 'STR:Map`{Var`,Value`}] [none] .)
                            (eq 'startSE[stateVar(StateOp), '__['_`,_['Var:Var, 'V:Value], 'SVDeclL:List`{PairVarValue`}], 'STR:Map`{Var`,Value`}] = 'startSE[stateVar(StateOp), 'SVDeclL:List`{PairVarValue`}, 'insert['Var:Var, 'V:Value, 'STR:Map`{Var`,Value`}]] [none] .) .

    op modCond : Condition -> Condition .
    eq modCond(T1 = T2) = searchSubVarConst(T1) = searchSubVarConst(T2) .

    op modRlConds : RuleSet -> RuleSet .
    eq modRlConds(none) = none .
    eq modRlConds(crl T1 => T2 if Cond [AttrSet] . RlSet) = (crl T1 => T2 if modCond(Cond) [AttrSet] .) modRlConds(RlSet) .
    eq modRlConds(Rule RlSet) = Rule modRlConds(RlSet) [owise] .

    op trMod : Module Qid Qid -> Module .
    eq trMod(M, StateOp, ValOp) = mod 'PARTIAL-SYMBOLIC-MOD is
                                    inclSEImports(getImports(M))
                                    sorts inclSESorts(getSorts(M)) .
                                    getSubsorts(M)
                                    modSEOps(getOps(M), StateOp, ValOp)
                                    getMbs(M)
                                    modSEEqs(getEqs(M), ValOp) inclSEEqs(StateOp)
                                    modRlConds(getRls(M))
                                  endm .

    op fuseMods : Module FModule -> Module .
    eq fuseMods(M, FM) = mod getName(M) is
                            getImports(M) getImports(FM)
                            sorts getSorts(M) ; getSorts(FM) .
                            getSubsorts(M) getSubsorts(FM)
                            getOps(M) getOps(FM)
                            getMbs(M) getMbs(FM)
                            getEqs(M) getEqs(FM)
                            getRls(M)
                          endm .

    op transformModSymb : Qid Qid Qid TrType -> Module .
    op transformModSymb : Module Qid Qid TrType -> Module .
    eq transformModSymb(ModId, StateOp, ValOp, TrId) = transformModSymb(upModule(ModId, true), StateOp, ValOp, TrId) .
    eq transformModSymb(M, StateOp, ValOp, TrId) = modRl(fuseMods(trMod(M, StateOp, ValOp), upModule('SMT-CONNECTION, true)),
                                                         StateOp, TrId) .
    ***op transformModSymb : QidList Qid Qid TrType -> Module .
    ***op transformModSymb : QidList Qid Qid TrType Module -> Module .
    ***eq transformModSymb(ModIdList, StateOp, ValOp, TrId) = transformModSymb(ModIdList, StateOp, ValOp, TrId, mod 'SEMANTICS is nil sorts none . none none none none none endm) .
    ***eq transformModSymb(nil, StateOp, ValOp, TrId, M) = modRl(fuseMods(mod 'PARTIAL-SYMBOLIC-MOD is
    ***                                                                        inclSEImports(getImports(M))
    ***                                                                        sorts inclSESorts(getSorts(M)) .
    ***                                                                        getSubsorts(M)
    ***                                                                        modSEOps(getOps(M), StateOp, ValOp)
    ***                                                                        getMbs(M)
    ***                                                                        modSEEqs(getEqs(M), ValOp) inclSEEqs(StateOp)
    ***                                                                        modRlConds(getRls(M))
    ***                                                                    endm, upModule('SMT-CONNECTION, true)),
    ***                                                            StateOp, TrId) .
    ***ceq transformModSymb(ModId ModIdList, StateOp, ValOp, TrId, AccM) = transformModSymb(ModIdList, StateOp, ValOp, TrId,
    ***                                                                    mod getName(AccM) is
    ***                                                                        getImports(M) getImports(AccM)
    ***                                                                        sorts getSorts(M) ; getSorts(AccM) .
    ***                                                                        getSubsorts(M) getSubsorts(AccM)
    ***                                                                        getOps(M) getOps(AccM)
    ***                                                                        getMbs(M) getMbs(AccM)
    ***                                                                        getEqs(M) getEqs(AccM)
    ***                                                                        getRls(M) getRls(AccM)
    ***                                                                    endm)
    ***    if M := upModule(ModId, true) .
    ***
    ***op transformModMaudeSE : QidList Module -> Module .
    ***eq transformModMaudeSE(nil, M) = modRl(mod 'SEMANTICS-MAUDE-SE-MOD is
    ***                                        inclSEImports(getImports(M))
    ***                                        sorts getSorts(M) .
    ***                                        getSubsorts(M)
    ***                                        getOps(M)
    ***                                        getMbs(M)
    ***                                        getEqs(M)
    ***                                        getRls(M)
    ***                                       endm, maudeSE) .
    ***ceq transformModMaudeSE(ModId ModIdList, AccM) = transformModMaudeSE(ModIdList,
    ***                                                 mod getName(AccM) is
    ***                                                     getImports(M) getImports(AccM)
    ***                                                     sorts getSorts(M) ; getSorts(AccM) .
    ***                                                     getSubsorts(M) getSubsorts(AccM)
    ***                                                     getOps(M) getOps(AccM)
    ***                                                     getMbs(M) getMbs(AccM)
    ***                                                     getEqs(M) getEqs(AccM)
    ***                                                     getRls(M) getRls(AccM)
    ***                                                 endm)
    ***    if M := upModule(ModId, false) .

    ***eq 'pr = 'protecting .

endfm

mod VERIFICATION-COMMANDS is

    pr MODULE-TRANSFORMER .
    pr LEXICAL .

    vars ModId StateOp SearchType ValOp TargetSt : Qid .
    var TrId : TrType .
    var PatternSEState : Term .
    var InitSEState : String . 
    var SearchCond : Condition .
    var Bound : Bound .
    var SolN : Nat .
    var ModIdList : QidList .
    var NeModIdList : NeQidList .
    var M : Module .
    var SVDeclL : List{PairVarValue} .
    var SymbCond : Boolean .

    op searchTr : Module Qid Qid TrType Qid String Term Condition Qid Bound Nat List{PairVarValue} Boolean -> ResultTriple .
    eq searchTr(M, StateOp, ValOp, TrId, TargetSt,
                  InitSEState,
                  PatternSEState,
                  SearchCond,
                  SearchType,
                  Bound,
                  SolN,
                  SVDeclL,
                  SymbCond)
                  =
                  metaSearch(transformModSymb(M, StateOp, ValOp, TrId),
                             searchSubVarConst('start['_where_[getTerm(metaParse(transformModSymb(M, StateOp, ValOp, TrId),
                                                                                       tokenize(InitSEState),
                                                                                       StateOp)),
                                                               upTerm(SymbCond)],
                                                      upTerm(SVDeclL)]),
                             PatternSEState,
                             SearchCond,
                             SearchType,
                             Bound,
                             SolN) .
    
    op searchPathTr : Module Qid Qid TrType Qid String Term Condition Qid Bound Nat List{PairVarValue} Boolean -> Trace? .
    eq searchPathTr(M, StateOp, ValOp, TrId, TargetSt,
                    InitSEState,
                    PatternSEState,
                    SearchCond,
                    SearchType,
                    Bound,
                    SolN,
                    SVDeclL,
                    SymbCond)
                    =
                    metaSearchPath(transformModSymb(M, StateOp, ValOp, TrId),
                                   searchSubVarConst('start['_where_[getTerm(metaParse(transformModSymb(M, StateOp, ValOp, TrId),
                                                                                       tokenize(InitSEState),
                                                                                       StateOp)),
                                                                             upTerm(SymbCond)],
                                                            upTerm(SVDeclL)]),
                                   PatternSEState,
                                   SearchCond,
                                   SearchType,
                                   Bound,
                                   SolN) .
    
    op searchSymb : Module Qid Qid String Term Condition Qid Bound Nat List{PairVarValue} Boolean -> ResultTriple .
    eq searchSymb(M, StateOp, ValOp,
                  InitSEState,
                  PatternSEState,
                  SearchCond,
                  SearchType,
                  Bound,
                  SolN,
                  SVDeclL,
                  SymbCond)
                  = searchTr(M, StateOp, ValOp, symb, 'SEState,
                        InitSEState,
                        PatternSEState,
                        SearchCond,
                        SearchType,
                        Bound,
                        SolN,
                        SVDeclL,
                        SymbCond) .

    op searchConcolic : Module Qid Qid String Term Condition Qid Bound Nat List{PairVarValue} Boolean -> ResultTriple .
    eq searchConcolic(M, StateOp, ValOp,
                      InitSEState,
                      PatternSEState,
                      SearchCond,
                      SearchType,
                      Bound,
                      SolN,
                      SVDeclL,
                      SymbCond)
                      = searchTr(M, StateOp, ValOp, conc, 'ConcolicState,
                                 InitSEState,
                                 PatternSEState,
                                 SearchCond,
                                 SearchType,
                                 Bound,
                                 SolN,
                                 SVDeclL,
                                 SymbCond) .

    op searchPathConcolic : Module Qid Qid String Term Condition Qid Bound Nat List{PairVarValue} Boolean -> Trace? .
    eq searchPathConcolic(M, StateOp, ValOp,
                          InitSEState,
                          PatternSEState,
                          SearchCond,
                          SearchType,
                          Bound,
                          SolN,
                          SVDeclL,
                          SymbCond)
                          = searchPathTr(M, StateOp, ValOp, conc, 'ConcolicState,
                                         InitSEState,
                                         PatternSEState,
                                         SearchCond,
                                         SearchType,
                                         Bound,
                                         SolN,
                                         SVDeclL,
                                         SymbCond) .

endm

mod MAUDE-SE-EXT is

    pr VERIFICATION-COMMANDS .
    pr META-SMT-SEARCH . 

    vars StateOp ValOp TrId SearchType Logic : Qid .
    var PatternSEState : Term .
    var InitSEState : String . 
    var SearchCond : Condition .
    var Bound : Bound .
    var SolN : Nat .
    var NeModIdList : NeQidList .
    var Fold : Bool .
    var M : Module .
    var SVDeclL : List{PairVarValue} .

    op searchMaudeSE : Module Qid Qid String Term Condition Qid Bound Nat Qid Bool List{PairVarValue} -> SmtResult2? .
    eq searchMaudeSE(M, StateOp, ValOp,
                     InitSEState,
                     PatternSEState,
                     SearchCond,
                     SearchType,
                     Bound,
                     SolN,
                     Logic, Fold,
                     SVDeclL)
                     = metaSmtSearch(transformModSymb(M, StateOp, ValOp, maudeSE),
                                     searchSubVarConst('startSE[getTerm(metaParse(transformModSymb(M, StateOp, ValOp, maudeSE),
                                                                                  tokenize(InitSEState),
                                                                                  StateOp)),
                                                                upTerm(SVDeclL), 'empty.Map`{Var`,Value`}]),
                                     PatternSEState,
                                     SearchCond,
                                     SearchType,
                                     Bound,
                                     SolN,
                                     Logic, Fold) .
    
    op searchPathMaudeSE : Module Qid Qid String Term Condition Qid Bound Nat Qid Bool List{PairVarValue} -> Trace2Result? .
    eq searchPathMaudeSE(M, StateOp, ValOp,
                         InitSEState,
                         PatternSEState,
                         SearchCond,
                         SearchType,
                         Bound,
                         SolN,
                         Logic, Fold,
                         SVDeclL)
                         = metaSmtSearchPath(transformModSymb(M, StateOp, ValOp, maudeSE),
                                             searchSubVarConst('startSE[getTerm(metaParse(transformModSymb(M, StateOp, ValOp, maudeSE),
                                                                                  tokenize(InitSEState),
                                                                                  StateOp)),
                                                                upTerm(SVDeclL), 'empty.Map`{Var`,Value`}]),
                                             PatternSEState,
                                             SearchCond,
                                             SearchType,
                                             Bound,
                                             SolN,
                                             Logic, Fold) .
endm