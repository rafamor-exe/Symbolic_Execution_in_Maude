load smt.maude
*** Test transformer with while language module
load while-semantics-concrete.maude

fmod MODULE-TRANSFORMER is
    pr META-LEVEL .
    pr STRING-OPS .

    vars T1 T2 Tcond Tmod Constraints Path : Term .
    var AttrSet : AttrSet .
    var RlSet : RuleSet .
    var Cond : Condition .
    var Header : Header .
    var ImportList : ImportList .
    var SortSet : SortSet .
    var SubsortDeclSet : SubsortDeclSet .
    var OpDeclSet : OpDeclSet .
    var MembAxSet : MembAxSet .
    var EquationSet : EquationSet .
    vars InstId StateOp OpId ModId Q ValOp TrId : Qid .
    vars M AccM : Module .
    var TL : TypeList .
    var T : Type .
    var S1 S2 : Sort .
    var Import : Import .
    vars ModIdList QL : QidList .
    var TermL : TermList .
    var NeTL : NeTermList .
    var Smain S S' : String .
    var N? : FindResult .
    var MVar : Variable .
    var MConst : Constant .
    var B : Bool .

    op modRl : Module Qid -> Module .
    eq modRl(M, 'symb) = mod 'SYMBOLIC-MOD is
                    getImports(M)
                    sorts getSorts(M) .
                    getSubsorts(M)
                    getOps(M)
                    getMbs(M)
                    getEqs(M)
                    rlToSymbolic(getRls(M), M)
                  endm .
    eq modRl(M, 'conc) = mod 'CONCOLIC-MOD is
                    getImports(M)
                    sorts getSorts(M) .
                    getSubsorts(M)
                    getOps(M)
                    getMbs(M)
                    getEqs(M)
                    rlToConcolic(getRls(M), M)
                  endm .

    op rlToSymbolic : RuleSet Module -> RuleSet .
    eq rlToSymbolic(none, M) = none .
    eq rlToSymbolic(rl T1 => T2 [label(InstId) AttrSet] . RlSet, M) = rl '_`{_`}<`{_`}[T1, 'Constraints:Boolean, 'Path:Path] => '_`{_`}<`{_`}[T2, 'Constraints:Boolean, '__['Path:Path, 'loc[upTerm(InstId)]]] [label(InstId) AttrSet] . rlToSymbolic(RlSet, M) .
    *** TODO: parametrize language-specific sorts (Map, BExp)
    ceq rlToSymbolic(crl T1 => T2 if Cond [label(InstId) AttrSet] . RlSet, M) = crl '_`{_`}<`{_`}[T1, 'Constraints:Boolean, 'Path:Path] => '_`{_`}<`{_`}[T2, 'Constraints:Boolean, '__['Path:Path, 'loc[upTerm(InstId)]]] if 'Constraints':Boolean := '_and_['Constraints:Boolean, 'evalB[Tcond]] /\ 'metaCheck[upTerm(M), 'upTerm['Constraints':Boolean]] = 'true.Bool [label(InstId) AttrSet] . rlToSymbolic(RlSet, M)
        if (Tcond = 'val['true.Bool]) := Cond .
    
    *** TODO: Transform rules to concolic
    ***     - Take into account that symbolic rules must not be applied to internal symbolic state during concolic exec
    ***     - Create another module? Just changing the rules to use the underlying equational theory 
    op rlToConcolic : RuleSet Module -> RuleSet .
    ***eq rlToSymbolic(none, M) = none .
    ***eq rlToSymbolic(rl T1 => T2 [label(InstId) AttrSet] . RlSet, M) = rl '_`{_`}<`{_`}[T1, 'Constraints:Boolean, 'Path:Path] => '_`{_`}<`{_`}[T2, 'Constraints:Boolean, '__['Path:Path, 'loc[upTerm(InstId)]]] [label(InstId) AttrSet] . rlToSymbolic(RlSet, M) .
    ***ceq rlToSymbolic(crl T1 => T2 if Cond [label(InstId) AttrSet] . RlSet, M) = crl '_`{_`}<`{_`}[T1, 'Constraints:Boolean, 'Path:Path] => '_`{_`}<`{_`}[T2, 'Constraints:Boolean, '__['Path:Path, 'loc[upTerm(InstId)]]] if 'Constraints':Boolean := '_and_['Constraints:Boolean, 'evalB[Tcond]] /\ 'metaCheck[upTerm(M), 'upTerm['Constraints':Boolean]] = 'true.Bool [label(InstId) AttrSet] . rlToSymbolic(RlSet, M)
    ***    if (Tcond = 'val['true.Bool]) := Cond .

    op inclSEImports : ImportList -> ImportList .
    eq inclSEImports(ImportList) = ImportList
                                   (protecting 'REAL-INTEGER .)
                                   (protecting 'LIST{'Location} * (sort 'List`{Location`} to 'Path) .)
                                   (protecting 'LIST{'Inst} * (sort 'List`{Inst`} to 'Program) .)
                                   (protecting 'META-LEVEL .) .

    op inclSESorts : SortSet -> SortSet .
    eq inclSESorts(SortSet) = SortSet ; 'SEState ; 'ConstrainedStart ;
                              'ConcolicState ; 'ConcolicStateCore . ***; 'Location    

    ***op updateStateSymb : OpDeclSet Qid -> OpDeclSet .
    ***eq updateStateSymb((op 'start : 'Program -> StateOp .) OpDeclSet, StateOp)
    
    op toSMTSorts : TypeList -> TypeList .
    eq toSMTSorts(nil) = nil .
    eq toSMTSorts('Bool TL) = 'Boolean toSMTSorts(TL) .
    eq toSMTSorts('Int TL) = 'Integer toSMTSorts(TL) .
    eq toSMTSorts('Rat TL) = 'Real toSMTSorts(TL) .
    eq toSMTSorts(T TL) = T toSMTSorts(TL) [owise] .

    ***op modSESubsorts : SubsortDeclSet -> SubsortDeclSet .
    ***eq modSESubsorts(none) = none .
    ***eq modSESubsorts((subsort S1 < S2 .) SubsortDeclSet) = (subsort toSMTSorts(S1) < toSMTSorts(S2) .) modSESubsorts(SubsortDeclSet) .

    op useSMTsorts : OpDeclSet Qid -> OpDeclSet .
    eq useSMTsorts(none, ValOp) = none .
    eq useSMTsorts((op ValOp : TL -> T [AttrSet] .) OpDeclSet, ValOp) = (op ValOp : toSMTSorts(TL) -> T [AttrSet] .)
                                                                        useSMTsorts(OpDeclSet, ValOp) . 
    eq useSMTsorts((op OpId : TL -> T [AttrSet] .) OpDeclSet, ValOp) = (op OpId : TL -> T [AttrSet] .) 
                                                                       useSMTsorts(OpDeclSet, ValOp) [owise] .

    *** Define the Symbolic State on top of the casual (concrete) state
    op modSEOps : OpDeclSet Qid Qid -> OpDeclSet .
    eq modSEOps(OpDeclSet, StateOp, ValOp) = useSMTsorts(OpDeclSet, ValOp)
                                             (op '_`{_`}<`{_`} : StateOp 'Boolean 'Path -> 'SEState [ctor] .)
                                             (op '_where_ : 'Program 'Boolean -> 'ConstrainedStart [ctor] .)
                                             (op 'evalB : 'BExp -> 'Boolean [none] .)
                                             (op '`[_`]`[_`]`[_`] : StateOp 'SEState 'Int -> 'ConcolicStateCore [ctor] .)
                                             (op '_`[_`]`[_/_`] : 'ConcolicStateCore 'Map`{Var`,Value`} 'Nat 'Bound -> 'ConcolicState [ctor] .) .
                                             ***(op 'loc : 'Qid -> 'Location [ctor] .)
                                             ***(op 'start : 'ConstrainedStart -> 'SEState [none] .)
                                             ***(op 'start : 'ConstrainedStart 'Program -> 'SEState [none] .)

    op modSEOpIds : Qid -> Qid .
    eq modSEOpIds('_==_) = '_===_ .
    eq modSEOpIds('_=/=_) = '_=/==_ . 
    eq modSEOpIds('_quo_) = '_div_ . 
    eq modSEOpIds(Q) = Q [owise] .

    op subSEVarSorts : Variable -> Variable .
    eq subSEVarSorts(MVar) = qid(string(getName(MVar)) + ":" + string(toSMTSorts(getType(MVar)))) .

    op subSEConstSorts : Constant -> Constant .
    eq subSEConstSorts(MConst) = qid(string(getName(MConst)) + "." + string(toSMTSorts(getType(MConst)))) .

    *** Substitute all Vars and Conts in Term
    op searchSubVarConst : TermList -> TermList .
    eq searchSubVarConst(empty) = empty .
    eq searchSubVarConst(MConst) = subSEConstSorts(MConst) .
    eq searchSubVarConst(MVar) = subSEVarSorts(MVar) .
    eq searchSubVarConst(OpId[T1]) = modSEOpIds(OpId)[searchSubVarConst(T1)] .
    eq searchSubVarConst(OpId[T1, NeTL]) = modSEOpIds(OpId)[searchSubVarConst(T1), searchSubVarConst(NeTL)] .
    eq searchSubVarConst((T1, NeTL)) = searchSubVarConst(T1), searchSubVarConst(NeTL) .

    *** Don't change Vars and Consts sorts but keep searching for Vals
    op subSETerm : Term Qid -> Term .
    eq subSETerm(MConst, ValOp) = MConst .
    eq subSETerm(MVar, ValOp) = MVar .
    eq subSETerm(OpId[T1], ValOp) = OpId[subSEVal(T1, ValOp)] .
    eq subSETerm(OpId[T1, NeTL], ValOp) = OpId[subSEVal(T1, ValOp), subSETermL(NeTL, ValOp)] .

    *** If Term is Val substitute all maude types by smt types, else keep searching for Vals
    op subSEVal : Term Qid -> Term .
    eq subSEVal(ValOp[TermL], ValOp) = ValOp[searchSubVarConst(TermL)] .
    eq subSEVal(T1, ValOp) = subSETerm(T1, ValOp) [owise] .

    *** Search for Vals in TermList
    op subSETermL : TermList Qid -> TermList .
    eq subSETermL(empty, ValOp) = empty .
    eq subSETermL(T1, ValOp) = subSEVal(T1, ValOp) .
    eq subSETermL((T1, NeTL), ValOp) = subSEVal(T1, ValOp), subSETermL(NeTL, ValOp) .


    op modSEEqs : EquationSet Qid -> EquationSet .
    eq modSEEqs(none, ValOp) = none .
    eq modSEEqs(eq T1 = T2 [AttrSet] . EquationSet, ValOp) = eq subSETermL(T1, ValOp) = subSETermL(T2, ValOp) [AttrSet] .
                                                             modSEEqs(EquationSet, ValOp) .
    
    op inclSEEqs : -> EquationSet .
    eq inclSEEqs = (eq 'evalB['val['B:Boolean]] = 'B:Boolean [none] .) .

    ***op transformModSymb : Module Qid Qid -> Module .
    ***op transformModSymb : Module Qid Qid Qid Qid Qid -> Module .
    ***eq transformModSymb(M, StateOp, ValOp) = modRl(mod 'PARTIAL-SYMBOLIC-MOD is
    ***                                            inclSEImports(getImports(M))
    ***                                            sorts inclSESorts(getSorts(M)) .
    ***                                            getSubsorts(M)
    ***                                            modSEOps(getOps(M), StateOp, ValOp)
    ***                                            getMbs(M)
    ***                                            modSEEqs(getEqs(M), ValOp) inclSEEqs
    ***                                            getRls(M)
    ***                                         endm) .
    op transformModSymb : QidList Qid Qid Qid -> Module .
    op transformModSymb : QidList Qid Qid Qid Module -> Module .
    eq transformModSymb(ModIdList, StateOp, ValOp, TrId) = transformModSymb(ModIdList, StateOp, ValOp, TrId, mod 'SEMANTICS is nil sorts none . none none none none none endm) .
    eq transformModSymb(nil, StateOp, ValOp, TrId, M) = modRl(mod 'PARTIAL-SYMBOLIC-MOD is
                                                                inclSEImports(getImports(M))
                                                                sorts inclSESorts(getSorts(M)) .
                                                                getSubsorts(M)
                                                                modSEOps(getOps(M), StateOp, ValOp)
                                                                getMbs(M)
                                                                modSEEqs(getEqs(M), ValOp) inclSEEqs
                                                                getRls(M)
                                                              endm, TrId) .
    ceq transformModSymb(ModId ModIdList, StateOp, ValOp, TrId, AccM) = transformModSymb(ModIdList, StateOp, ValOp, TrId,
                                                                        mod getName(AccM) is
                                                                            getImports(AccM)
                                                                            sorts getSorts(M) ; getSorts(AccM) .
                                                                            getSubsorts(M) getSubsorts(AccM)
                                                                            getOps(M) getOps(AccM)
                                                                            getMbs(M) getMbs(AccM)
                                                                            getEqs(M) getEqs(AccM)
                                                                            getRls(M) getRls(AccM)
                                                                        endm)
        if M := upModule(ModId, false) .

    ***eq 'pr = 'protecting .

endfm

mod VERIFICATION-COMMANDS is

    pr MODULE-TRANSFORMER .
    pr LEXICAL .

    vars ModId StateOp SearchType ValOp TrId : Qid .
    var PatternSEState : Term .
    var InitSEState : String . 
    var SearchCond : Condition .
    var Bound : Bound .
    var SolN : Nat .
    var ModIdList : QidList .
    var NeModIdList : NeQidList .

    op searchTr : NeQidList Qid Qid Qid String Term Condition Qid Bound Nat -> ResultTriple .
    eq searchTr(ModId, StateOp, ValOp, TrId,
                  InitSEState,
                  PatternSEState,
                  SearchCond,
                  SearchType,
                  Bound,
                  SolN)
                  =
                  metaSearch(transformModSymb(ModId, StateOp, ValOp, TrId, mod 'SEMANTICS is nil sorts none . none none none none none endm),
                             getTerm(metaParse(transformModSymb(ModId, StateOp, ValOp, TrId, mod 'SEMANTICS is nil sorts none . none none none none none endm),
                             tokenize(InitSEState), 'SEState)),
                             PatternSEState,
                             SearchCond,
                             SearchType,
                             Bound,
                             SolN) .
    eq searchTr(ModId NeModIdList, StateOp, ValOp, TrId,
                  InitSEState,
                  PatternSEState,
                  SearchCond,
                  SearchType,
                  Bound,
                  SolN)
                  =
                  metaSearch(transformModSymb(ModId NeModIdList, StateOp, ValOp, TrId, mod 'SEMANTICS is nil sorts none . none none none none none endm),
                             getTerm(metaParse(transformModSymb(ModId NeModIdList, StateOp, ValOp, TrId, mod 'SEMANTICS is nil sorts none . none none none none none endm),
                             tokenize(InitSEState), 'SEState)),
                             PatternSEState,
                             SearchCond,
                             SearchType,
                             Bound,
                             SolN) .
    
    op searchSymb : NeQidList Qid Qid String Term Condition Qid Bound Nat -> ResultTriple .
    eq searchSymb(ModId NeModIdList, StateOp, ValOp,
                  InitSEState,
                  PatternSEState,
                  SearchCond,
                  SearchType,
                  Bound,
                  SolN)
                  = searchTr(ModId NeModIdList, StateOp, ValOp, 'symb,
                        InitSEState,
                        PatternSEState,
                        SearchCond,
                        SearchType,
                        Bound,
                        SolN) .

    op searchConcolic : NeQidList Qid Qid String Term Condition Qid Bound Nat -> ResultTriple .
    eq searchConcolic(ModId NeModIdList, StateOp, ValOp,
                      InitSEState,
                      PatternSEState,
                      SearchCond,
                      SearchType,
                      Bound,
                      SolN)
                      = searchTr(ModId NeModIdList, StateOp, ValOp, 'conc,
                                 InitSEState,
                                 PatternSEState,
                                 SearchCond,
                                 SearchType,
                                 Bound,
                                 SolN) .

endm
