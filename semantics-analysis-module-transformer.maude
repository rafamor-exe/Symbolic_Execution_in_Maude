load semantics-basics/smt-conversion.maude

*** Test transformer with while language module
***load language-semantics/while-semantics-concrete.maude
***set trace on .

fmod SE-LOCS-MOD is
    protecting QID .
    sort Location .
    op loc : Qid -> Location [ctor] .
endfm

view Location from TRIV to SE-LOCS-MOD is
  sort Elt to Location .
endv

view Integer from TRIV to REAL-INTEGER is
  sort Elt to Integer .
endv
view Real from TRIV to REAL-INTEGER is
  sort Elt to Real .
endv
view Boolean from TRIV to REAL-INTEGER is
  sort Elt to Boolean .
endv

fmod SMT-CONNECTION is
    pr SMT-CONVERSION .
    pr SE-LOCS-MOD .

    protecting MAP{Var, Integer} * (sort Map{Var, Integer} to IStoreS) * (op _|->_ to _|->Is_ ) .
    protecting MAP{Var, Real} * (sort Map{Var, Real} to RStoreS) * (op _|->_ to _|->Rs_ ) .
    protecting MAP{Var, Boolean} * (sort Map{Var, Boolean} to BStoreS) * (op _|->_ to _|->Bs_ ) .
    

    sort AssignmentSMT .
    sorts PairSVar PairSVarL NePairSVarL .
    subsort PairSVar < NePairSVarL < PairSVarL .

    op _<--_ : Real Real -> AssignmentSMT [ctor] .
    op _<--_ : Integer Integer -> AssignmentSMT [ctor] .
    op _<--_ : Boolean Boolean -> AssignmentSMT [ctor] .
    op _,_ : AssignmentSMT AssignmentSMT -> AssignmentSMT .
    op failed : -> AssignmentSMT [ctor] .

    op get-SMTassignment : Boolean -> AssignmentSMT [special (id-hook SpecialHubSymbol)] .

    *** Symbolic variable initialization pair
    op _,_ : Qid Integer -> PairSVar [ctor] .
    op _,_ : Qid Real -> PairSVar [ctor] .
    op _,_ : Qid Boolean -> PairSVar [ctor] .

    op nil : -> PairSVarL [ctor] .
    op __ : PairSVarL PairSVarL -> PairSVarL [ctor assoc id: nil prec 25] .
endfm

fmod MODULE-TRANSFORMER is
    pr STRING-OPS .
    pr SMT-CONNECTION .

    sort TrType .
    
    ops symb conc maudeSE clconc : -> TrType [ctor] .

    vars Trm T1 T2 Tcond Tmod Constraints TSTR TIL : Term .
    var AttrSet : AttrSet .
    var RlSet : RuleSet .
    var Rule : Rule .
    var Cond : Condition .
    var Header : Header .
    var ImportList : ImportList .
    var SortSet : SortSet .
    var SubsortDeclSet : SubsortDeclSet .
    var OpDeclSet : OpDeclSet .
    var OpDecl : OpDecl .
    var MembAxSet : MembAxSet .
    var EquationSet : EquationSet .
    var Eq : Equation .
    vars InstId StateOp OpId ModId Q ValOp Q' Q'' X Y : Qid .
    var TrId : TrType .
    vars M M1 M2 AccM SymbM : Module .
    var FM : FModule .
    var TL : TypeList .
    var T : Type .
    var S1 S2 : Sort .
    var Import : Import .
    vars ModIdList QL : QidList .
    var TermL : TermList .
    var NeTL : NeTermList .
    var Smain S S' C C2 : String .
    var N? : FindResult .
    var MVar : Variable .
    var MConst : Constant .
    var B : Bool .
    var N : Nat .
    var I : Integer .
    vars EqC EqC2 : EqCondition .
    vars Cond1 Cond2 CondS : Condition .
    var SbSort : SubsortDecl .

    op modRl : RuleSet Qid TrType -> RuleSet .
    op modRl : RuleSet TrType -> RuleSet .
    eq modRl(RlSet, StateOp, symb) = rlToSymbolic(RlSet) .
    eq modRl(RlSet, StateOp, conc) = rlToConcolic(RlSet, StateOp) .
    eq modRl(RlSet, StateOp, maudeSE) = rlToMaudeSE(modRlConds(RlSet)) .
    eq modRl(RlSet, StateOp, clconc) = rlToClConcolic(RlSet, StateOp) inclClConcCrl(StateOp) .
    
    *** Generic Term substitution: substitute T1 by T2 in Trm
    op subT : Term Term Term -> Term .
    eq subT(MConst, MConst, T2) = T2 .
    eq subT(MVar, MVar, T2) = T2 .
    eq subT(OpId[Trm], T1, T2) = OpId[subT(Trm, T1, T2)] .
    eq subT(OpId[Trm, NeTL], T1, T2) = OpId[subT(Trm, T1, T2), subTL(NeTL, T1, T2)] .
    eq subT(Trm, T1, T2) = Trm [owise] .

    op subTL : TermList Term Term -> Term .
    eq subTL(empty, T1, T2) = empty .
    eq subTL(Trm, T1, T2) = subT(Trm, T1, T2) .
    eq subTL((Trm, NeTL), T1, T2) = subT(Trm, T1, T2), subTL(NeTL, T1, T2) .


    op rlToSymbolic : RuleSet -> RuleSet .
    eq rlToSymbolic(none) = none .
    eq rlToSymbolic(rl T1 => T2 [label(InstId) AttrSet] . RlSet) = rl '_`{_`}[symbMirror(T1), 'Constraints:Boolean]
                                                                      => '_`{_`}[symbMirror(T2), 'Constraints:Boolean]
                                                                      [label(qid(string(InstId) + "-S")) AttrSet] .
                                                                   rlToSymbolic(RlSet) .
    *** TODO: parametrize language-specific sorts (Map, BExp)
    ceq rlToSymbolic(crl T1 => T2 if Cond [label(InstId) AttrSet] . RlSet) = crl '_`{_`}[symbMirror(T1), 'Constraints:Boolean]
                                                                                  => '_`{_`}[symbMirror(T2), 'Constraints:Boolean]
                                                                                  if 'Constraints':Boolean := '_and_['Constraints:Boolean, subSTR2(searchSubVarConst(Tcond))]
                                                                                  /\ 'metaCheck[upTerm(upModule('REAL-INTEGER, false)), 'upTerm['Constraints':Boolean]] = 'true.Bool
                                                                             [label(qid(string(InstId) + "-S")) AttrSet] .
                                                                             rlToSymbolic(RlSet)
        if (Tcond = 'true.Boolean) := Cond .
    
    *** State var general definition
    op stateVar : Qid -> Variable .
    eq stateVar(StateOp) = qid(string('State) + ":" + string(StateOp)) .
    op stateVar : Qid Nat -> Variable .
    eq stateVar(StateOp, N) = qid(string('State) + string(N, 10) + ":" + string(StateOp)) .

    op symbState : Qid -> Term .
    eq symbState(StateOp) = '_`{_`}[stateVar(StateOp), 'Constraints:Boolean] .
    op symbState : Qid Nat -> Term .
    eq symbState(StateOp, N) = '_`{_`}[stateVar(StateOp, N), 'Constraints:Boolean] .

    op concolicState : Qid -> Term .
    eq concolicState(StateOp) = '`[_`]`[_`]`[_`]`[_`][stateVar(StateOp, 0), symbState(StateOp, 1), 'N:Nat, 'STRInit:Stores] .
    op concolicState : Qid Term -> Term .
    eq concolicState(StateOp, T1) = '`[_`]`[_`]`[_`]`[_`][T1, symbState(StateOp, 1), 'N:Nat, 'STRInit:Stores] .

    op concolicStateExt : Qid -> Term .
    eq concolicStateExt(StateOp) = '_`[_$$_`]['`[_`]`[_`]`[_`]`[_`][stateVar(StateOp, 0), symbState(StateOp, 1), 'N:Nat, 'STRInit:Stores], 'PC:Program, 'PS:Program] .
    op concolicStateExt : Qid Term -> Term .
    eq concolicStateExt(StateOp, T1) = '_`[_$$_`]['`[_`]`[_`]`[_`]`[_`][T1, symbState(StateOp, 1), 'N:Nat, 'STRInit:Stores], 'PC:Program, 'PS:Program] .

    op subIL : Term Term -> Term .
    eq subIL(T1, TIL) = subT(subT(subT(subT(subT(subT(T1, 'IL:Program, TIL), 'IL1:Program, 'IL1S:Program), 'IL2:Program, 'IL2S:Program), 'IExp:IExp, 'IExpS:IExp), 'RExp:RExp, 'RExpS:RExp), 'BExp:BExp, 'BExpS:BExp) .

    op subSTR : Term Term -> Term .
    eq subSTR(T1, TSTR) = subT(subT(subT(subT(T1, 'ISTR:IStore, 'getIStore[TSTR]), 'RSTR:RStore, 'getRStore[TSTR]), 'BSTR:BStore, 'getBStore[TSTR]), 'STR:Stores, TSTR) .

    op subSTR2 : Term -> Term .
    eq subSTR2(T1) = subT(subT(subT(subT(T1, 'ISTR:IStore, 'ISTRS:IStoreS), 'RSTR:RStore, 'RSTRS:RStoreS), 'BSTR:BStore, 'BSTRS:BStoreS), 'STR:Stores, 'STRS:Stores) .

    op symbMirror : Term -> Term .
    eq symbMirror(T1) = subSTR2(subIL(searchSubVarConst(T1), 'ILS:Program)) .

    op rlToConcolic : RuleSet Qid -> RuleSet .
    eq rlToConcolic(none, StateOp) = none .
    *** Symbolic rules must not be applied to internal symbolic state during concolic exec
    *** These rules cannot be merged into one with 'if_then_else_fi because that distinction should be done at this level (transformation), not delayed
    eq rlToConcolic(rl T1 => T2 [label(InstId) AttrSet] . RlSet, StateOp) = (rl '_`[_$$_`]['`[_`]`[_`]`[_`]`[_`][T1, '_`{_`}[symbMirror(T1), 'Constraints:Boolean], 'N:Nat, 'STRInit:Stores], 'PC:Program, 'PS:Program]
                                                                            =>
                                                                            '_`[_$$_`]['`[_`]`[_`]`[_`]`[_`][T2, '_`{_`}[symbMirror(T2), 'Constraints:Boolean], 'N:Nat, 'STRInit:Stores], 'PC:Program, 'PS:Program]
                                                                            [label(InstId) AttrSet] .)
                                                                            rlToConcolic(RlSet, StateOp) .

    *** TODO: Generalize hardcoded STR variable indicating the concrete store
    ceq rlToConcolic(crl T1 => T2 if Cond [label(InstId) AttrSet] . RlSet, StateOp) = (crl '_`[_$$_`]['`[_`]`[_`]`[_`]`[_`][T1, '_`{_`}[symbMirror(T1), 'Constraints:Boolean], 'N:Nat, 'STRInit:Stores], 'PC:Program, 'PS:Program]
                                                                                          =>
                                                                                          '_`[_$$_`]['`[_`]`[_`]`[_`]`[_`][T2, '_`{_`}[symbMirror(T2), 'Constraints':Boolean], 'N:Nat, 'STRInit:Stores], 'PC:Program, 'PS:Program]
                                                                                          if Cond
                                                                                          /\ 'Constraints':Boolean := '_and_['Constraints:Boolean, subSTR2(searchSubVarConst(Tcond))]
                                                                                          [label(InstId) AttrSet] .)
                                                                                      (crl '_`[_$$_`]['`[_`]`[_`]`[_`]`[_`][T1, '_`{_`}[symbMirror(T1), 'Constraints:Boolean], 'N:Nat, 'STRInit:Stores], 'PC:Program, 'PS:Program]
                                                                                          =>
                                                                                          '_`[_$$_`]['`[_`]`[_`]`[_`]`[_`]['updateStore['updateProgram[T2, 'PC:Program], 'init-CStore['_|_|_['empty.IStore, 'empty.RStore, 'empty.BStore], 'STRInit:Stores, 'Constraints':Boolean]],
                                                                                                                      '_`{_`}['updateStore['updateProgram[symbMirror(T2), 'PS:Program], 'STRInit:Stores], 'Constraints':Boolean], '_+_['N:Nat, 's_['0.Nat]], 'STRInit:Stores], 'PC:Program, 'PS:Program]
                                                                                          if Cond
                                                                                          /\ 'Constraints':Boolean := '_and_['Constraints:Boolean, 'not_[subSTR2(searchSubVarConst(Tcond))]]
                                                                                          /\ 'metaCheck[upTerm(upModule('REAL-INTEGER, false)), 'upTerm['Constraints':Boolean]] = 'true.Bool
                                                                                          [label(qid(string(InstId) + "-bis")) AttrSet] .)
                                                                                          rlToConcolic(RlSet, StateOp)
        if (Tcond = 'true.Bool) := Cond .

    op rlToClConcolic : RuleSet Qid -> RuleSet .
    ***eq rlToClConcolic(none, StateOp) = none .
    ***eq rlToClConcolic(rl T1 => T2 [AttrSet] . RlSet, StateOp) = rlToConcolic(rl T1 => T2 [AttrSet] . RlSet, StateOp)
    ***                                                               rlToClConcolic(RlSet, StateOp) .
    ***ceq rlToClConcolic(crl T1 => T2 if Cond [label(InstId) AttrSet] . RlSet, StateOp) = (crl '`[_`]`[_`]`[_`]`[_`][T1, '_`{_`}[stateVar(StateOp), 'Constraints:Boolean], 'N:Nat, 'STRInit:Stores]
    ***                                                                                      =>
    ***                                                                                      '`[_`]`[_`]`[_`]`[_`][T2, '_`{_`}[stateVar(StateOp), 'Constraints':Boolean], 'N:Nat, 'STRInit:Stores]
    ***                                                                                      if 'Constraints':Boolean := '_and_['Constraints:Boolean, subT(Tcond, 'STR:Stores, 'getStore[stateVar(StateOp)])]
    ***                                                                                      /\ 'metaCheck[upTerm(upModule('REAL-INTEGER, false)), 'upTerm[Tcond]] = 'true.Bool
    ***                                                                                      [label(InstId) AttrSet] .)
    ***                                                                                      rlToConcolic(RlSet, StateOp)
    ***    if (Tcond = 'true.Boolean) := Cond .
    
    op inclClConcCrl : Qid -> RuleSet .
    ***eq inclClConcCrl(StateOp) = (crl '`[_`]`[_`]`[_`]`[_`][T1, '_`{_`}[stateVar(StateOp), 'Constraints:Boolean], 'N:Nat, 'STRInit:Stores]
    ***                                =>
    ***                                '`[_`]`[_`]`[_`]`[_`][subT('updateProgram[T2, 'getProgram[stateVar(StateOp)]], 'STR:Stores, 'init-CStore['STRInit:Stores, 'Constraints':Boolean]),
    ***                                                            '_`{_`}['updateStore[stateVar(StateOp), 'STRInit:Stores], 'Constraints':Boolean], '_+_['N:Nat, 's_['0.Nat]], 'STRInit:Stores]
    ***                                if 'metaCheck[upTerm(upModule('REAL-INTEGER, false)), 'upTerm['Constraints:Boolean]] = 'true.Bool
    ***                                [label(qid("re-exec")) AttrSet] .)
    
    op rlToMaudeSE : RuleSet -> RuleSet .
    eq rlToMaudeSE(none) = none .
    eq rlToMaudeSE(rl T1 => T2 [label(InstId) AttrSet] . RlSet) = (rl modOpStoreRec(T1) => modOpStoreRec(T2) 
                                                                   [label(InstId) AttrSet] .)
                                                                  rlToMaudeSE(RlSet) .
    eq rlToMaudeSE(crl T1 => T2 if CondS [label(InstId) AttrSet] . RlSet) = (crl modOpStoreRec(T1) => modOpStoreRec(T2) 
                                                                             if CondS 
                                                                             [label(InstId) AttrSet] .)
                                                                            rlToMaudeSE(RlSet) .
    eq rlToMaudeSE(Rule RlSet) = Rule rlToMaudeSE(RlSet) [owise] .

    op modSEImports : ImportList -> ImportList .
    eq modSEImports(ImportList) = ImportList .
    ***eq modSEImports(nil) = nil .
    ***eq modSEImports((protecting 'MAP{X, Y} .) ImportList) = (protecting 'MAP{X, Y} .) 
    ***                                                        (protecting 'MAP{X, toSMTSorts(Y)} .) 
    ***                                                        modSEImports(ImportList) .
    ***eq modSEImports(Import ImportList) = Import modSEImports(ImportList) [owise] .

    op inclSEImports : ImportList -> ImportList .
    eq inclSEImports(ImportList) = ImportList ***modSEImports(ImportList)
                                   ***(protecting 'MAP{'Var, 'Integer} * (sort 'Map`{'Var`,'Integer`} to 'IStoreS) * (op '_|->_ to '_|->Is_ [ctor]) .)
                                   ***(protecting 'MAP{'Var, 'Real} * (sort 'Map`{'Var`,'Real`} to 'RStoreS) * (op '_|->_ to '_|->Rs_ [ctor]) .)
                                   ***(protecting 'MAP{'Var, 'Boolean} * (sort 'Map`{'Var`,'Boolean`} to 'BStoreS) * (op '_|->_ to '_|->Bs_ [ctor]) .) .
                                   ***(protecting 'REAL-INTEGER .)
                                   ***(protecting 'META-LEVEL .)
                                   ***(protecting 'SMT-CONNECTION .)
                                   ***(protecting 'SE-LOCS-MOD .)
                                   ***(protecting 'LIST{'Location} * (sort 'List`{Location`} to 'Path) .)
                                   ***(protecting 'LIST{'PairVarValue} .)
                                   ***(protecting 'LIST{'Inst} * (sort 'List`{Inst`} to 'Program) .)

    op inclSESorts : SortSet -> SortSet .
    eq inclSESorts(SortSet) = SortSet ; 'SEState ; 'ConstrainedStart ;
                              'ConcolicState ; 'ConcolicStateCore ; 'ConcolicStateExt .    

    op toSMTSorts : TypeList -> TypeList .
    eq toSMTSorts(nil) = nil .
    eq toSMTSorts('Bool TL) = 'Boolean toSMTSorts(TL) .
    eq toSMTSorts('Int TL) = 'Integer toSMTSorts(TL) .
    eq toSMTSorts('Rat TL) = 'Real toSMTSorts(TL) .
    eq toSMTSorts('Zero TL) = 'Integer toSMTSorts(TL) .
    eq toSMTSorts('IStore TL) = 'IStoreS toSMTSorts(TL) .
    eq toSMTSorts('RStore TL) = 'RStoreS toSMTSorts(TL) .
    eq toSMTSorts('BStore TL) = 'BStoreS toSMTSorts(TL) .

    eq toSMTSorts(T TL) = T toSMTSorts(TL) [owise] .

    ***op modSESubsorts : SubsortDeclSet -> SubsortDeclSet .
    ***eq modSESubsorts(none) = none .
    ***eq modSESubsorts((subsort S1 < S2 .) SubsortDeclSet) = (subsort toSMTSorts(S1) < toSMTSorts(S2) .) modSESubsorts(SubsortDeclSet) .

    op toSymb : Qid -> Qid .
    eq toSymb(OpId) = qid(string(OpId) + "S") .

    op useSMTsorts : OpDeclSet Qid -> OpDeclSet .
    eq useSMTsorts(none, ValOp) = none .
    eq useSMTsorts((op 'eval : TL -> T [AttrSet] .) OpDeclSet, ValOp) = (op toSymb('eval) : toSMTSorts(TL) -> toSMTSorts(T) [AttrSet] .)
                                                                        useSMTsorts(OpDeclSet, ValOp) . 
    eq useSMTsorts((op 'evalI : TL -> T [AttrSet] .) OpDeclSet, ValOp) = (op toSymb('evalI) : toSMTSorts(TL) -> toSMTSorts(T) [AttrSet] .)
                                                                        useSMTsorts(OpDeclSet, ValOp) . 
    eq useSMTsorts((op 'evalR : TL -> T [AttrSet] .) OpDeclSet, ValOp) = (op toSymb('evalR) : toSMTSorts(TL) -> toSMTSorts(T) [AttrSet] .)
                                                                        useSMTsorts(OpDeclSet, ValOp) . 
    eq useSMTsorts((op 'evalB : TL -> T [AttrSet] .) OpDeclSet, ValOp) = (op toSymb('evalB) : toSMTSorts(TL) -> toSMTSorts(T) [AttrSet] .)
                                                                        useSMTsorts(OpDeclSet, ValOp) .
    eq useSMTsorts(OpDecl OpDeclSet, ValOp) = OpDecl useSMTsorts(OpDeclSet, ValOp) [owise] .

    op modOpSigConc : OpDeclSet Qid -> OpDeclSet .
    eq modOpSigConc(none, ValOp) = none .
    *** On concolic analysis ValOp refers to semantically-relevant value operator, not syntax 'val
    eq modOpSigConc((op ValOp : TL -> T [AttrSet] .) OpDeclSet, ValOp) = (op ValOp : TL -> T [AttrSet] .)
                                                                         (op ValOp : toSMTSorts(TL) -> T [AttrSet] .)
                                                                         modOpSigConc(OpDeclSet, ValOp) . 
    eq modOpSigConc((op 'eval : TL -> T [AttrSet] .) OpDeclSet, ValOp) = (op 'eval : TL -> T [AttrSet] .)
                                                                         (op toSymb('eval) : toSMTSorts(TL) -> toSMTSorts(T) [AttrSet] .)
                                                                         modOpSigConc(OpDeclSet, ValOp) . 
    eq modOpSigConc((op 'evalI : TL -> T [AttrSet] .) OpDeclSet, ValOp) = (op 'evalI : TL -> T [AttrSet] .)
                                                                          (op toSymb('evalI) : toSMTSorts(TL) -> toSMTSorts(T) [AttrSet] .)
                                                                          modOpSigConc(OpDeclSet, ValOp) . 
    eq modOpSigConc((op 'evalR : TL -> T [AttrSet] .) OpDeclSet, ValOp) = (op 'evalR : TL -> T [AttrSet] .)
                                                                          (op toSymb('evalR) : toSMTSorts(TL) -> toSMTSorts(T) [AttrSet] .)
                                                                          modOpSigConc(OpDeclSet, ValOp) . 
    eq modOpSigConc((op 'evalB : TL -> T [AttrSet] .) OpDeclSet, ValOp) = (op 'evalB : TL -> T [AttrSet] .)
                                                                          (op toSymb('evalB) : toSMTSorts(TL) -> toSMTSorts(T) [AttrSet] .)
                                                                          modOpSigConc(OpDeclSet, ValOp) . 
    eq modOpSigConc(OpDecl OpDeclSet, ValOp) = OpDecl modOpSigConc(OpDeclSet, ValOp) [owise] .

    op inclSEOps : Qid -> OpDeclSet .
    eq inclSEOps(StateOp) = (op '_`{_`} : StateOp 'Boolean -> 'SEState [ctor] .)
                            (op '_where_ : StateOp 'Boolean -> 'ConstrainedStart [ctor] .)
                            (op '__where_ : StateOp StateOp 'Boolean -> 'ConstrainedStart [ctor] .)
                            ***(op 'evalB : 'BExp -> 'Boolean [none] .)
                            (op '`[_`]`[_`]`[_`]`[_`] : StateOp 'SEState 'Int 'Stores -> 'ConcolicState [ctor] .)
                            (op '_`[_$$_`] : 'ConcolicState 'Program 'Program -> 'ConcolicStateExt [ctor] .)
                            ***(op '_`[_`] : 'ConcolicStateCore 'Stores -> 'ConcolicState [ctor] .)
                            (op '_|_|_ : 'IStoreS 'RStoreS 'BStoreS -> 'Stores [ctor] .)
                            (op 'init-CStore : 'Stores 'Stores 'Boolean -> 'Stores [none] .)
                            (op '$apply-SMTassignment : 'Stores 'Stores 'AssignmentSMT -> 'Stores [none] .)
                            (op 'initialize-def : 'IStoreS -> 'IStore [none] .)
                            (op 'initialize-def : 'RStoreS -> 'RStore [none] .)
                            (op 'initialize-def : 'BStoreS -> 'BStore [none] .)
                            ***(op 'size : 'Boolean -> 'Nat [none] .)
                            (op 'start : StateOp 'PairSVarL -> 'ConcolicState [none] .)
                            (op 'start : 'ConstrainedStart 'PairSVarL -> 'ConcolicState [none] .)
                            (op '$start : StateOp 'PairSVarL 'Stores 'Boolean -> 'ConcolicState [none] .)
                            (op 'startC : StateOp StateOp 'PairSVarL -> 'ConcolicStateExt [none] .)
                            (op 'startC : 'ConstrainedStart 'PairSVarL -> 'ConcolicStateExt [none] .)
                            (op '$startC : StateOp StateOp 'PairSVarL 'Stores 'Boolean -> 'ConcolicStateExt [none] .)
                            (op 'startSE : StateOp 'PairSVarL 'Stores -> StateOp [none] .) .

    *** Define the Symbolic State on top of the casual (concrete) state
    op modSEOps : OpDeclSet Qid Qid TrType -> OpDeclSet .
    eq modSEOps(OpDeclSet, StateOp, ValOp, conc) = modOpSigConc(OpDeclSet, ValOp) ***OpDeclSet
                                                   inclSEOps(StateOp) .
    eq modSEOps(OpDeclSet, StateOp, ValOp, TrId) = useSMTsorts(OpDeclSet, ValOp) ***OpDeclSet
                                                   inclSEOps(StateOp) [owise] .

    op modSEOpIds : Qid -> Qid .
    eq modSEOpIds('_==_) = '_===_ .
    eq modSEOpIds('_=/=_) = '_=/==_ . 
    eq modSEOpIds('_quo_) = '_div_ . 
    eq modSEOpIds('rat) = 'toReal . 
    eq modSEOpIds('eval) = toSymb('eval) .
    eq modSEOpIds('evalI) = toSymb('evalI) .
    eq modSEOpIds('evalR) = toSymb('evalR) .
    eq modSEOpIds('evalB) = toSymb('evalB) .
    eq modSEOpIds(Q) = Q [owise] .

    op subSEVarSorts : Variable -> Variable .
    eq subSEVarSorts(MVar) = qid(string(getName(MVar)) + ":" + string(toSMTSorts(getType(MVar)))) .

    op subSEConstSorts : Constant -> Constant .
    eq subSEConstSorts(MConst) = qid(string(getName(MConst)) + "." + string(toSMTSorts(getType(MConst)))) .

    *** Substitute all Vars and Consts in TermList with SMT correspondence
    op searchSubVarConst : TermList -> TermList .
    eq searchSubVarConst(empty) = empty .
    eq searchSubVarConst(MConst) = subSEConstSorts(MConst) .
    eq searchSubVarConst(MVar) = subSEVarSorts(MVar) .
    eq searchSubVarConst(OpId[T1]) = modSEOpIds(OpId)[searchSubVarConst(T1)] .
    eq searchSubVarConst(OpId[T1, NeTL]) = modSEOpIds(OpId)[searchSubVarConst(T1), searchSubVarConst(NeTL)] .
    eq searchSubVarConst((T1, NeTL)) = searchSubVarConst(T1), searchSubVarConst(NeTL) .

    op convert : Constant Type -> Constant .
    eq convert(MConst, 'Int) = 'toInteger[MConst] .
    eq convert(MConst, 'Rat) = 'toReal[MConst] .
    eq convert(MConst, 'Bool) = 'toBoolean[MConst] .
    eq convert(MConst, T) = MConst [owise] .
    op convert : Variable Type -> Variable .
    eq convert(MVar, 'Int) = 'toInteger[MVar] .
    eq convert(MVar, 'Rat) = 'toReal[MVar] .
    eq convert(MVar, 'Bool) = 'toBoolean[MVar] .
    eq convert(MVar, T) = MVar [owise] .

    *** Don't change Vars and Consts sorts but keep searching for Vals
    op subSETermSTR : Term -> Term .
    eq subSETermSTR(MConst) = convert(MConst, getType(MConst)) .
    eq subSETermSTR(MVar) = searchSubVarConst(MVar) .
    eq subSETermSTR('val[T1]) = 'val[T1] .
    eq subSETermSTR('_`,_['ISTR:IStore, '_|->I_[TermL]]) = '_`,_['ISTR:IStoreS, '_|->Is_[searchSubVarConst(TermL)]] .
    eq subSETermSTR('_`,_['RSTR:RStore, '_|->R_[TermL]]) = '_`,_['RSTR:RStoreS, '_|->Rs_[searchSubVarConst(TermL)]] .
    eq subSETermSTR('_`,_['BSTR:BStore, '_|->B_[TermL]]) = '_`,_['BSTR:BStoreS, '_|->Bs_[searchSubVarConst(TermL)]] .
    eq subSETermSTR(OpId[T1]) = modSEOpIds(OpId)[subSETermSTR(T1)] [owise] .
    eq subSETermSTR(OpId[T1, NeTL]) = modSEOpIds(OpId)[subSETermSTR(T1), modOpStoreRec(NeTL)] .

    op modOpStoreRec : TermList -> TermList .
    eq modOpStoreRec(empty) = empty .
    eq modOpStoreRec(T1) = subSETermSTR(T1) .
    eq modOpStoreRec((T1, NeTL)) = subSETermSTR(T1), modOpStoreRec(NeTL) .

    op modEqs : EquationSet Qid TrType -> EquationSet .
    eq modEqs(EquationSet, ValOp, conc) = modConcEqs(EquationSet, ValOp) .
    eq modEqs(EquationSet, ValOp, TrId) = modSEEqs(EquationSet, ValOp) [owise] .
    
    op modConcEqs : EquationSet Qid -> EquationSet .
    eq modConcEqs(none, ValOp) = none .
    eq modConcEqs(eq 'eval[NeTL] = T2 [AttrSet] . EquationSet, ValOp) = (eq 'eval[NeTL] = T2 [AttrSet] .) 
                                                                        (eq toSymb('eval)[modOpStoreRec(NeTL)] = modOpStoreRec(T2) [AttrSet] .)
                                                                        modConcEqs(EquationSet, ValOp) .
    eq modConcEqs(ceq 'eval[NeTL] = T2 if EqC [AttrSet] . EquationSet, ValOp) = (ceq 'eval[NeTL] = T2 if EqC [AttrSet] .)
                                                                                (ceq toSymb('eval)[modOpStoreRec(NeTL)] = searchSubVarConst(T2) if modCond(EqC) [AttrSet] .)
                                                                                modConcEqs(EquationSet, ValOp) .
    eq modConcEqs(eq 'evalI['val['I:Int], NeTL] = MVar [AttrSet] . EquationSet, ValOp) = (eq 'evalI['val['I:Int], NeTL] = MVar [AttrSet] .) 
                                                                                         (eq toSymb('evalI)[modOpStoreRec(('val['I:Int], NeTL))] = convert(MVar, getType(MVar)) [AttrSet] .)
                                                                                         modConcEqs(EquationSet, ValOp) .
    eq modConcEqs(eq 'evalR['val['R:Rat], NeTL] = MVar [AttrSet] . EquationSet, ValOp) = (eq 'evalR['val['R:Rat], NeTL] = MVar [AttrSet] .) 
                                                                                         (eq toSymb('evalR)[modOpStoreRec(('val['R:Rat], NeTL))] = convert(MVar, getType(MVar)) [AttrSet] .)
                                                                                         modConcEqs(EquationSet, ValOp) .
    eq modConcEqs(eq 'evalB['val['B:Bool], NeTL] = MVar [AttrSet] . EquationSet, ValOp) = (eq 'evalB['val['B:Bool], NeTL] = MVar [AttrSet] .)
                                                                                          (eq toSymb('evalB)[modOpStoreRec(('val['B:Bool], NeTL))] = convert(MVar, getType(MVar)) [AttrSet] .)
                                                                                          modConcEqs(EquationSet, ValOp) .
    eq modConcEqs(eq 'evalI[NeTL] = T2 [AttrSet] . EquationSet, ValOp) = (eq 'evalI[NeTL] = T2 [AttrSet] .) 
                                                                         (eq toSymb('evalI)[modOpStoreRec(NeTL)] = modOpStoreRec(T2) [AttrSet] .)
                                                                         modConcEqs(EquationSet, ValOp) [owise] .
    eq modConcEqs(eq 'evalR[NeTL] = T2 [AttrSet] . EquationSet, ValOp) = (eq 'evalR[NeTL] = T2 [AttrSet] .) 
                                                                         (eq toSymb('evalR)[modOpStoreRec(NeTL)] = modOpStoreRec(T2) [AttrSet] .)
                                                                         modConcEqs(EquationSet, ValOp) [owise] .
    eq modConcEqs(eq 'evalB[NeTL] = T2 [AttrSet] . EquationSet, ValOp) = (eq 'evalB[NeTL] = T2 [AttrSet] .)
                                                                         (eq toSymb('evalB)[modOpStoreRec(NeTL)] = modOpStoreRec(T2) [AttrSet] .)
                                                                         modConcEqs(EquationSet, ValOp) [owise] .
    eq modConcEqs(Eq EquationSet, ValOp) = Eq modConcEqs(EquationSet, ValOp) [owise] .
  
    op modSEEqs : EquationSet Qid -> EquationSet .
    eq modSEEqs(none, ValOp) = none .
    eq modSEEqs(eq 'eval[NeTL] = T2 [AttrSet] . EquationSet, ValOp) = (eq toSymb('eval)[modOpStoreRec(NeTL)] = modOpStoreRec(T2) [AttrSet] .)
                                                                      modSEEqs(EquationSet, ValOp) .
    eq modSEEqs(ceq 'eval[NeTL] = T2 if EqC [AttrSet] . EquationSet, ValOp) = (ceq toSymb('eval)[modOpStoreRec(NeTL)] = modOpStoreRec(T2) if modCond(EqC) [AttrSet] .)
                                                                              modSEEqs(EquationSet, ValOp) .
    eq modSEEqs(eq 'evalI['val['I:Int], NeTL] = MVar [AttrSet] . EquationSet, ValOp) = (eq toSymb('evalI)[modOpStoreRec(('val['I:Int], NeTL))] = convert(MVar, getType(MVar)) [AttrSet] .)
                                                                                       modSEEqs(EquationSet, ValOp) .
    eq modSEEqs(eq 'evalR['val['R:Rat], NeTL] = MVar [AttrSet] . EquationSet, ValOp) = (eq toSymb('evalR)[modOpStoreRec(('val['R:Rat], NeTL))] = convert(MVar, getType(MVar)) [AttrSet] .)
                                                                                       modSEEqs(EquationSet, ValOp) .
    eq modSEEqs(eq 'evalB['val['B:Bool], NeTL] = MVar [AttrSet] . EquationSet, ValOp) = (eq toSymb('evalB)[modOpStoreRec(('val['B:Bool], NeTL))] = convert(MVar, getType(MVar)) [AttrSet] .)
                                                                                        modSEEqs(EquationSet, ValOp) .
    eq modSEEqs(eq 'evalI[NeTL] = T2 [AttrSet] . EquationSet, ValOp) = (eq toSymb('evalI)[modOpStoreRec(NeTL)] = modOpStoreRec(T2) [AttrSet] .)
                                                                       modSEEqs(EquationSet, ValOp) [owise] .
    eq modSEEqs(eq 'evalR[NeTL] = T2 [AttrSet] . EquationSet, ValOp) = (eq toSymb('evalR)[modOpStoreRec(NeTL)] = modOpStoreRec(T2) [AttrSet] .)
                                                                       modSEEqs(EquationSet, ValOp) [owise] .
    eq modSEEqs(eq 'evalB[NeTL] = T2 [AttrSet] . EquationSet, ValOp) = (eq toSymb('evalB)[modOpStoreRec(NeTL)] = modOpStoreRec(T2) [AttrSet] .) 
                                                                       modSEEqs(EquationSet, ValOp) [owise] .
    eq modSEEqs(Eq EquationSet, ValOp) = Eq modSEEqs(EquationSet, ValOp) [owise] .
    
    op inclSEEqs : Qid -> EquationSet .
    eq inclSEEqs(StateOp) = (eq 'init-CStore['STR:Stores, 'STRS:Stores, 'Constraints:Boolean] = '$apply-SMTassignment['STR:Stores, 'STRS:Stores, 'get-SMTassignment['Constraints:Boolean]] [none] .)
                            (eq '$apply-SMTassignment['_|_|_['ISTR:IStore, 'RSTR:RStore, 'BSTR:BStore], '_|_|_['ISTRS:IStoreS, '_`,_['_|->Rs_['Var:Var, 'R:Real], 'RSTRS:RStoreS], 'BSTRS:BStoreS], '_<--_['R:Real, 'Rconc:Real]] = '_|_|_['ISTR:IStore, '_`,_['_|->R_['Var:Var, 'toRat['Rconc:Real]], 'RSTR:RStore], 'BSTR:BStore] [none] .)
                            (eq '$apply-SMTassignment['_|_|_['ISTR:IStore, 'RSTR:RStore, 'BSTR:BStore], '_|_|_['ISTRS:IStoreS, '_`,_['_|->Rs_['Var:Var, 'R:Real], 'RSTRS:RStoreS], 'BSTRS:BStoreS], '_`,_['_<--_['R:Real, 'Rconc:Real], 'AssignmentSMT:AssignmentSMT]] = '$apply-SMTassignment['_|_|_['ISTR:IStore, '_`,_['_|->R_['Var:Var, 'toRat['Rconc:Real]], 'RSTR:RStore], 'BSTR:BStore], '_|_|_['ISTRS:IStoreS, 'RSTRS:RStoreS, 'BSTRS:BStoreS], 'AssignmentSMT:AssignmentSMT] [none] .)
                            (eq '$apply-SMTassignment['_|_|_['ISTR:IStore, 'RSTR:RStore, 'BSTR:BStore], '_|_|_['_`,_['_|->Is_['Var:Var, 'I:Integer], 'ISTRS:IStoreS], 'RSTRS:RStoreS, 'BSTRS:BStoreS], '_<--_['I:Integer, 'Iconc:Integer]] = '_|_|_['_`,_['_|->I_['Var:Var, 'toInt['Iconc:Integer]], 'ISTR:IStore], 'RSTR:RStore, 'BSTR:BStore] [none] .)
                            (eq '$apply-SMTassignment['_|_|_['ISTR:IStore, 'RSTR:RStore, 'BSTR:BStore], '_|_|_['_`,_['_|->Is_['Var:Var, 'I:Integer], 'ISTRS:IStoreS], 'RSTRS:RStoreS, 'BSTRS:BStoreS], '_`,_['_<--_['I:Integer, 'Iconc:Integer], 'AssignmentSMT:AssignmentSMT]] = '$apply-SMTassignment['_|_|_['_`,_['_|->I_['Var:Var, 'toInt['Iconc:Integer]], 'ISTR:IStore], 'RSTR:RStore, 'BSTR:BStore], '_|_|_['ISTRS:IStoreS, 'RSTRS:RStoreS, 'BSTRS:BStoreS], 'AssignmentSMT:AssignmentSMT] [none] .)
                            (eq '$apply-SMTassignment['_|_|_['ISTR:IStore, 'RSTR:RStore, 'BSTR:BStore], '_|_|_['ISTRS:IStoreS, 'RSTRS:RStoreS, '_`,_['_|->Bs_['Var:Var, 'B:Boolean], 'BSTRS:BStoreS]], '_<--_['B:Boolean, 'Bconc:Boolean]] = '_|_|_['ISTR:IStore, 'RSTR:RStore, '_`,_['_|->B_['Var:Var, 'toBool['Bconc:Boolean]], 'BSTR:BStore]] [none] .)
                            (eq '$apply-SMTassignment['_|_|_['ISTR:IStore, 'RSTR:RStore, 'BSTR:BStore], '_|_|_['ISTRS:IStoreS, 'RSTRS:RStoreS, '_`,_['_|->Bs_['Var:Var, 'B:Boolean], 'BSTRS:BStoreS]], '_`,_['_<--_['B:Boolean, 'Bconc:Boolean], 'AssignmentSMT:AssignmentSMT]] = '$apply-SMTassignment['_|_|_['ISTR:IStore, 'RSTR:RStore, '_`,_['_|->B_['Var:Var, 'toBool['Bconc:Boolean]], 'BSTR:BStore]], '_|_|_['ISTRS:IStoreS, 'RSTRS:RStoreS, 'BSTRS:BStoreS], 'AssignmentSMT:AssignmentSMT] [none] .)
                            (eq '$apply-SMTassignment['STR:Stores, 'STRS:Stores, 'failed.AssignmentSMT] = 'STR:Stores [none] .)
                            (eq '$apply-SMTassignment['STR:Stores, '_|_|_['ISTRS:IStoreS, 'RSTRS:RStoreS, 'BSTRS:BStoreS], '_<--_['true.Boolean, 'true.Boolean]] = '_|_|_['initialize-def['ISTRS:IStoreS], 'initialize-def['RSTRS:RStoreS], 'initialize-def['BSTRS:BStoreS]] [none] .)
                            (eq 'initialize-def['empty.IStoreS] = 'empty.IStore [none] .)
                            (eq 'initialize-def['empty.RStoreS] = 'empty.RStore [none] .)
                            (eq 'initialize-def['empty.BStoreS] = 'empty.BStore [none] .)
                            (eq 'initialize-def['_`,_['_|->Is_['Var:Var, 'I:Integer], 'ISTRS:IStoreS]] = '_`,_['_|->I_['Var:Var, '0.Int], 'initialize-def['ISTRS:IStoreS]] [none] .)
                            (eq 'initialize-def['_`,_['_|->Rs_['Var:Var, 'R:Real], 'RSTRS:RStoreS]] = '_`,_['_|->R_['Var:Var, '0.Rat], 'initialize-def['RSTRS:RStoreS]] [none] .)
                            (eq 'initialize-def['_`,_['_|->Bs_['Var:Var, 'B:Boolean], 'BSTRS:BStoreS]] = '_`,_['_|->B_['Var:Var, 'true.Bool], 'initialize-def['BSTRS:BStoreS]] [none] .)
                            (eq 'not_['not_['B:Boolean]] = 'B:Boolean [none] .)
                            ***(eq 'size['C1:Boolean] = ''s_['0.Nat] [none] .)
                            ***(eq 'size['_and_['C1:Boolean, 'Constraints:Boolean]] = ''s_['0.Nat] + 'size['Constraints:Boolean] [none] .)
                            (eq 'startC[stateVar(StateOp, 0), stateVar(StateOp, 1), 'SVDeclL:PairSVarL] = '$startC[stateVar(StateOp, 0), stateVar(StateOp, 1), 'SVDeclL:PairSVarL, '_|_|_['empty.IStoreS, 'empty.RStoreS, 'empty.BStoreS], 'true.Boolean] [none] .)
                            (eq 'startC['__where_[stateVar(StateOp, 0), stateVar(StateOp, 1), 'B:Boolean], 'SVDeclL:PairSVarL] = '$startC[stateVar(StateOp, 0), stateVar(StateOp, 1), 'SVDeclL:PairSVarL, '_|_|_['empty.IStoreS, 'empty.RStoreS, 'empty.BStoreS], 'B:Boolean] [none] .)
                            (eq '$startC[stateVar(StateOp, 0), stateVar(StateOp, 1), 'nil.PairSVarL, 'STR:Stores, 'B:Boolean] = '_`[_$$_`]['`[_`]`[_`]`[_`]`[_`]['updateStore[stateVar(StateOp, 0), 'init-CStore['_|_|_['empty.IStore, 'empty.RStore, 'empty.BStore], 'STR:Stores, 'B:Boolean]], '_`{_`}['updateStore[stateVar(StateOp, 1), 'STR:Stores], 'B:Boolean], '0.Nat, 'STR:Stores], 'getProgram[stateVar(StateOp, 0)], 'getProgram[stateVar(StateOp, 1)]] [none] .)
                            (eq '$startC[stateVar(StateOp, 0), stateVar(StateOp, 1), '__['_`,_['Var:Qid, 'I1:Integer], 'SVDeclL:PairSVarL], '_|_|_['ISTRS:IStoreS, 'RSTRS:RStoreS, 'BSTRS:BStoreS], 'B:Boolean] = '$startC[stateVar(StateOp, 0), stateVar(StateOp, 1), 'SVDeclL:PairSVarL, '_|_|_['insert['iv['Var:Qid], 'I1:Integer, 'ISTRS:IStoreS], 'RSTRS:RStoreS, 'BSTRS:BStoreS], 'B:Boolean] [none] .)
                            (eq '$startC[stateVar(StateOp, 0), stateVar(StateOp, 1), '__['_`,_['Var:Qid, 'R1:Real], 'SVDeclL:PairSVarL], '_|_|_['ISTRS:IStoreS, 'RSTRS:RStoreS, 'BSTRS:BStoreS], 'B:Boolean] = '$startC[stateVar(StateOp, 0), stateVar(StateOp, 1), 'SVDeclL:PairSVarL, '_|_|_['ISTRS:IStoreS, 'insert['rv['Var:Qid], 'R1:Real, 'RSTRS:RStoreS], 'BSTRS:BStoreS], 'B:Boolean] [none] .)
                            (eq '$startC[stateVar(StateOp, 0), stateVar(StateOp, 1), '__['_`,_['Var:Qid, 'B1:Boolean], 'SVDeclL:PairSVarL], '_|_|_['ISTRS:IStoreS, 'RSTRS:RStoreS, 'BSTRS:BStoreS], 'B:Boolean] = '$startC[stateVar(StateOp, 0), stateVar(StateOp, 1), 'SVDeclL:PairSVarL, '_|_|_['ISTRS:IStoreS, 'RSTRS:RStoreS, 'insert['bv['Var:Qid], 'B1:Boolean, 'BSTRS:BStoreS]], 'B:Boolean] [none] .)
                            
                            (eq 'startSE[stateVar(StateOp), 'nil.PairSVarL, 'STR:Stores] = 'updateStore[stateVar(StateOp), 'STR:Stores] [none] .)
                            (eq 'startSE[stateVar(StateOp), '__['_`,_['Var:Qid, 'I1:Integer], 'SVDeclL:PairSVarL], '_|_|_['ISTRS:IStoreS, 'RSTRS:RStoreS, 'BSTRS:BStoreS]] = 'startSE[stateVar(StateOp), 'SVDeclL:PairSVarL, '_|_|_['insert['iv['Var:Qid], 'I1:Integer, 'ISTRS:IStoreS], 'RSTRS:RStoreS, 'BSTRS:BStoreS]] [none] .)
                            (eq 'startSE[stateVar(StateOp), '__['_`,_['Var:Qid, 'R1:Real], 'SVDeclL:PairSVarL], '_|_|_['ISTRS:IStoreS, 'RSTRS:RStoreS, 'BSTRS:BStoreS]] = 'startSE[stateVar(StateOp), 'SVDeclL:PairSVarL, '_|_|_['ISTRS:IStoreS, 'insert['rv['Var:Qid], 'R1:Real, 'RSTRS:RStoreS], 'BSTRS:BStoreS]] [none] .)
                            (eq 'startSE[stateVar(StateOp), '__['_`,_['Var:Qid, 'B1:Boolean], 'SVDeclL:PairSVarL], '_|_|_['ISTRS:IStoreS, 'RSTRS:RStoreS, 'BSTRS:BStoreS]] = 'startSE[stateVar(StateOp), 'SVDeclL:PairSVarL, '_|_|_['ISTRS:IStoreS, 'RSTRS:RStoreS, 'insert['bv['Var:Qid], 'B1:Boolean, 'BSTRS:BStoreS]]] [none] .) .

    op modCond : Condition -> Condition .
    eq modCond(T1 = T2) = searchSubVarConst(T1) = searchSubVarConst(T2) .
    eq modCond(T1 := T2) = searchSubVarConst(T1) := searchSubVarConst(T2) .
    eq modCond(EqC /\ EqC2) = modCond(EqC) /\ modCond(EqC2) .
    eq modCond(Cond1 /\ Cond2) = modCond(Cond1) /\ modCond(Cond2) .
    eq modCond(Cond1) = Cond1 [owise] .

    op modRlConds : RuleSet -> RuleSet .
    eq modRlConds(none) = none .
    eq modRlConds(crl T1 => T2 if Cond [AttrSet] . RlSet) = (crl T1 => T2 if modCond(Cond) [AttrSet] .) modRlConds(RlSet) .
    eq modRlConds(Rule RlSet) = Rule modRlConds(RlSet) [owise] .

    op trMod : Module Qid Qid TrType -> Module .
    eq trMod(M, StateOp, ValOp, TrId) = mod 'PARTIAL-SYMBOLIC-MOD is
                                          inclSEImports(getImports(M))
                                          sorts inclSESorts(getSorts(M)) .
                                          getSubsorts(M)
                                          modSEOps(getOps(M), StateOp, ValOp, TrId)
                                          getMbs(M)
                                          modEqs(getEqs(M), ValOp, TrId) inclSEEqs(StateOp)
                                          modRl(getRls(M), StateOp, TrId)
                                        endm .

    op fuseMods : Module FModule -> Module .
    eq fuseMods(M, FM) = mod getName(M) is
                            getImports(M) getImports(FM)
                            sorts getSorts(M) ; getSorts(FM) .
                            getSubsorts(M) getSubsorts(FM)
                            getOps(M) getOps(FM)
                            getMbs(M) getMbs(FM)
                            getEqs(M) getEqs(FM)
                            getRls(M)
                          endm .

    op transformModSymb : Qid Qid Qid TrType -> Module .
    op transformModSymb : Module Qid Qid TrType -> Module .
    eq transformModSymb(ModId, StateOp, ValOp, TrId) = transformModSymb(upModule(ModId, true), StateOp, ValOp, TrId) .
    eq transformModSymb(M, StateOp, ValOp, TrId) = fuseMods(trMod(M, StateOp, ValOp, TrId), upModule('SMT-CONNECTION, true)) .

endfm

mod VERIFICATION-COMMANDS is

    pr MODULE-TRANSFORMER .
    pr LEXICAL .

    vars ModId StateOp SearchType ValOp TargetSt : Qid .
    var TrId : TrType .
    var PatternSEState : Term .
    var InitSEState : String . 
    var SearchCond : Condition .
    var Bound : Bound .
    var SolN : Nat .
    var ModIdList : QidList .
    var NeModIdList : NeQidList .
    var M : Module .
    var SVDeclL : PairSVarL .
    var SymbCond : Boolean .

    op searchTr : Module Qid Qid TrType Qid String Term Condition Qid Bound Nat PairSVarL Boolean -> ResultTriple .
    eq searchTr(M, StateOp, ValOp, TrId, TargetSt,
                  InitSEState,
                  PatternSEState,
                  SearchCond,
                  SearchType,
                  Bound,
                  SolN,
                  SVDeclL,
                  SymbCond)
                  =
                  metaSearch(transformModSymb(M, StateOp, ValOp, TrId),
                             'startC['__where_[getTerm(metaParse(M,
                                                                 tokenize(InitSEState),
                                                                 StateOp)),
                                               getTerm(metaParse(M,
                                                                 tokenize(InitSEState),
                                                                 StateOp)),
                                               searchSubVarConst(upTerm(SymbCond))],
                                     searchSubVarConst(upTerm(SVDeclL))],
                             PatternSEState,
                             SearchCond,
                             SearchType,
                             Bound,
                             SolN) .
    
    op searchPathTr : Module Qid Qid TrType Qid String Term Condition Qid Bound Nat PairSVarL Boolean -> Trace? .
    eq searchPathTr(M, StateOp, ValOp, TrId, TargetSt,
                    InitSEState,
                    PatternSEState,
                    SearchCond,
                    SearchType,
                    Bound,
                    SolN,
                    SVDeclL,
                    SymbCond)
                    =
                    metaSearchPath(transformModSymb(M, StateOp, ValOp, TrId),
                                   'startC['__where_[getTerm(metaParse(M,
                                                                       tokenize(InitSEState),
                                                                       StateOp)),
                                                     getTerm(metaParse(M,
                                                                       tokenize(InitSEState),
                                                                       StateOp)),
                                                     searchSubVarConst(upTerm(SymbCond))],
                                           searchSubVarConst(upTerm(SVDeclL))],
                                   PatternSEState,
                                   SearchCond,
                                   SearchType,
                                   Bound,
                                   SolN) .
    
    op searchSymb : Module Qid Qid String Term Condition Qid Bound Nat PairSVarL Boolean -> ResultTriple .
    eq searchSymb(M, StateOp, ValOp,
                  InitSEState,
                  PatternSEState,
                  SearchCond,
                  SearchType,
                  Bound,
                  SolN,
                  SVDeclL,
                  SymbCond)
                  = searchTr(M, StateOp, ValOp, symb, 'SEState,
                        InitSEState,
                        PatternSEState,
                        SearchCond,
                        SearchType,
                        Bound,
                        SolN,
                        SVDeclL,
                        SymbCond) .

    op searchConcolic : Module Qid Qid String Term Condition Qid Bound Nat PairSVarL Boolean -> ResultTriple .
    eq searchConcolic(M, StateOp, ValOp,
                      InitSEState,
                      PatternSEState,
                      SearchCond,
                      SearchType,
                      Bound,
                      SolN,
                      SVDeclL,
                      SymbCond)
                      = searchTr(M, StateOp, ValOp, conc, 'ConcolicState,
                                 InitSEState,
                                 PatternSEState,
                                 SearchCond,
                                 SearchType,
                                 Bound,
                                 SolN,
                                 SVDeclL,
                                 SymbCond) .

    op searchPathConcolic : Module Qid Qid String Term Condition Qid Bound Nat PairSVarL Boolean -> Trace? .
    eq searchPathConcolic(M, StateOp, ValOp,
                          InitSEState,
                          PatternSEState,
                          SearchCond,
                          SearchType,
                          Bound,
                          SolN,
                          SVDeclL,
                          SymbCond)
                          = searchPathTr(M, StateOp, ValOp, conc, 'ConcolicState,
                                         InitSEState,
                                         PatternSEState,
                                         SearchCond,
                                         SearchType,
                                         Bound,
                                         SolN,
                                         SVDeclL,
                                         SymbCond) .

endm

mod MAUDE-SE-EXT is

    pr VERIFICATION-COMMANDS .
    pr META-SMT-SEARCH . 

    vars StateOp ValOp TrId SearchType Logic : Qid .
    var PatternSEState : Term .
    var InitSEState : String . 
    var SearchCond : Condition .
    var Bound : Bound .
    var SolN : Nat .
    var NeModIdList : NeQidList .
    var Fold : Bool .
    var M : Module .
    var SVDeclL : PairSVarL .

    op searchMaudeSE : Module Qid Qid String Term Condition Qid Bound Nat Qid Bool PairSVarL -> SmtResult2? .
    eq searchMaudeSE(M, StateOp, ValOp,
                     InitSEState,
                     PatternSEState,
                     SearchCond,
                     SearchType,
                     Bound,
                     SolN,
                     Logic, Fold,
                     SVDeclL)
                     = metaSmtSearch(transformModSymb(M, StateOp, ValOp, maudeSE),
                                     'startSE[getTerm(metaParse(transformModSymb(M, StateOp, ValOp, maudeSE),
                                                                                  tokenize(InitSEState),
                                                                                  StateOp)),
                                                                searchSubVarConst(upTerm(SVDeclL)), 
                                                                '_|_|_['empty.IStoreS, 'empty.RStoreS, 'empty.BStoreS]],
                                     PatternSEState,
                                     SearchCond,
                                     SearchType,
                                     Bound,
                                     SolN,
                                     Logic, Fold) .
    
    op searchPathMaudeSE : Module Qid Qid String Term Condition Qid Bound Nat Qid Bool PairSVarL -> Trace2Result? .
    eq searchPathMaudeSE(M, StateOp, ValOp,
                         InitSEState,
                         PatternSEState,
                         SearchCond,
                         SearchType,
                         Bound,
                         SolN,
                         Logic, Fold,
                         SVDeclL)
                         = metaSmtSearchPath(transformModSymb(M, StateOp, ValOp, maudeSE),
                                             'startSE[getTerm(metaParse(transformModSymb(M, StateOp, ValOp, maudeSE),
                                                                                  tokenize(InitSEState),
                                                                                  StateOp)),
                                                                searchSubVarConst(upTerm(SVDeclL)), 
                                                                '_|_|_['empty.IStoreS, 'empty.RStoreS, 'empty.BStoreS]],
                                             PatternSEState,
                                             SearchCond,
                                             SearchType,
                                             Bound,
                                             SolN,
                                             Logic, Fold) .
endm