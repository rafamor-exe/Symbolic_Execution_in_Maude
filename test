MaudeSE> smt-search [1] # "var1" := p:Real ; | empty # =>* # nil | "var1" |-> p:Real #   such that p:Real > toReal(1) using QF_LRA .

Solution 1 (state 1)

Symbolic state:
 # nil | "var1" |-> #1-V3:Real #

Constraint:
 V0:Real === p:Real and V1:Real === p:Real and not p:Real <= 1/1 and V0:Real === #2-RealVal:Real and #1-V3:Real === #2-RealVal:Real and V1:Real === #1-V3:Real

Substitution:
 V1:Real <-- #1-V3:Real


Assignment:
 #1-V3:Real <-- 2/1
 #2-RealVal:Real <-- 2/1
 V0:Real <-- 2/1
 V1:Real <-- 2/1
 p:Real <-- 2/1


Concrete state:
 # nil | "var1" |-> 2/1 #


MaudeSE> smt-search [1] start("var1" := p:Real ;) =>* # nil | "var1" |-> {type real, val val(p:Real)} #  such that p:Real > toReal(1) using QF_LRA .

Solution 1 (state 1)

Symbolic state:
 # nil | "var1" |-> {type real, val val(#1-V5:Real)} #

Constraint:
 V0:Real === p:Real and V1:Real === p:Real and not p:Real <= 1/1 and V0:Real === #2-RealVal:Real and #1-V5:Real === #2-RealVal:Real and V1:Real === #1-V5:Real

Substitution:
 V1:Real <-- #1-V5:Real


Assignment:
 #1-V5:Real <-- 2/1
 #2-RealVal:Real <-- 2/1
 V0:Real <-- 2/1
 V1:Real <-- 2/1
 p:Real <-- 2/1


Concrete state:
 # nil | "var1" |-> {type real, val val(2/1)} #


MaudeSE> smt-search [1] start('var1 := p:Real ;) =>* # nil | 'var1 |-> {type real, val val(p:Real)} #  such that p:Real > toReal(1) using QF_LRA .

Solution 1 (state 1)

Symbolic state:
 # nil | 'var1 |-> {type real, val val(V0:Real)} #

Constraint:
 V0:Real === p:Real and V1:Real === p:Real and not p:Real <= 1/1 and V1:Real === V0:Real

Substitution:
 V1:Real <-- V0:Real


Assignment:
 V0:Real <-- 2/1
 V1:Real <-- 2/1
 p:Real <-- 2/1


Concrete state:
 # nil | 'var1 |-> {type real, val val(2/1)} #


smt-search [1] start('var1 := p:Real ; if ('var1 < q:Real) then {'var2 := toReal(5) ;}) =>* # nil | 'var1 |-> {type real, val val(p:Real)}, 'var2 |-> {type real, val val(toReal(5))} #  such that p:Real > toReal(1) using QF_LRA .

******
***NOTE: errors exiting the execution from Maude configurations => maude-se not parsing some instruction in the file

smt-search [1] in WHILE-MAUDE : # 'var1 := p:Real ; | empty # =>* # nil | 'var1 |-> p:Real #   such that p:Real > toReal(1) using QF_LRA .
smt-search [1] in WHILE-MAUDE : # 'var1 := p:Real ; | empty # =>* # nil | STR:Map{Var, Real} #   such that p:Real > toReal(1) using QF_LRA .

smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; 'var2 := q:Real ;) =>* # nil | 'var1 |-> p:Real, 'var2 |-> q:Real #   such that p:Real > toReal(1) and q:Real < toReal(6) using QF_LRA .

smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; if (p:Real < q:Real) then {'var2 := q:Real ;}) =>* # if (p:Real < q:Real) then {'var2 := q:Real ;} else {nil} | 'var1 |-> p:Real #   such that p:Real > toReal(1) and q:Real < toReal(6) using QF_LRA .

smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; if (p:Real < q:Real) then {'var2 := q:Real ;}) =>* # nil | 'var1 |-> p:Real, 'var2 |-> q:Real #   such that p:Real > toReal(1) and q:Real < toReal(6) using QF_LRA .
smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; if (q:Real < p:Real) then {'var2 := q:Real ;}) =>* # nil | 'var1 |-> p:Real, 'var2 |-> q:Real #   such that p:Real > toReal(1) and q:Real < toReal(6) using QF_LRA .

smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; if (p:Real < q:Real) then {'var2 := toReal(5) ;}) =>* # nil | 'var1 |-> p:Real, 'var2 |-> toReal(5) #   such that p:Real > toReal(1) and q:Real < toReal(6) using QF_LRA .
smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; if (p:Real < q:Real) then {'var2 := toReal(5) ;}) =>* # nil | 'var1 |-> p:Real, 'var2 |-> q:Real #   such that p:Real > toReal(1) and q:Real < toReal(6) using QF_LRA .

smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; if (('var1 |-> p:Real)['var1] < q:Real) then {'var2 := toReal(5) ;}) =>* # nil | 'var1 |-> p:Real, 'var2 |-> toReal(5) #   such that p:Real > toReal(1) using QF_LRA .

smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; if (p:Real < q:Real) then {'var2 := q:Real ;}) =>* # nil | STR:Map{Var, Real} #   such that p:Real > toReal(1) and q:Real < toReal(6) using QF_LRA .

smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; if (p:Real < q:Real) then {'var2 := q:Real ;}) =>* # IL:List{Inst} | STR:Map{Var, Real} #   such that p:Real > toReal(1) and q:Real < toReal(6) using QF_LRA .

smt-search [1] in WHILE-MAUDE : start('var1 := (p:Real + z:Real) ; if ((p:Real + z:Real) < q:Real) then {'var2 := q:Real ;}) =>* # IL:List{Inst} | STR:Map{Var, Real} #   such that p:Real > toReal(1) and q:Real < toReal(6) using QF_LRA .

smt-search [1] in WHILE-MAUDE : start('var1 := (p:Real + z:Real) ; if ((p:Real + z:Real) < q:Real) then {'var2 := q:Real ;}) =>* # nil | STR:Map{Var, Real} #   such that p:Real > toReal(1) and q:Real < toReal(6) using QF_LRA .

smt-search [1] in WHILE-MAUDE : start('var1 := (p:Real + z:Real) ; if ((p:Real + z:Real) < q:Real) then {'var2 := q:Real ;}) =>* # nil | 'var1 |-> p:Real, 'var2 |-> toReal(5) #   such that p:Real > toReal(1) and q:Real < toReal(6) using QF_LRA .

smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; if (('var1 |-> p:Real)['var1] < q:Real) then {'var2 := toReal(5) ;} while (q:Real < toReal(1)) do {'var2 := toReal(1) ; }) =>* # nil | STR:Map{Var, Real} #   such that p:Real > toReal(1) using QF_LRA .


smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; if ('var1 < toReal(5)) then {'var2 := toReal(5) ;}) =>* # nil | STR:Map{Var, Real} #   such that p:Real > toReal(1) using QF_LRA .

smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; if ('var1 < toReal(5)) then {'var2 := toReal(5) ;} else {'var2 := toReal(6) ;} ) =>* # nil | ('var2 |-> toReal(6), STR:Map{Var, Real}) #   such that p:Real > toReal(1) using QF_LRA .


smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; if ('var1 < toReal(5)) then {'var2 := toReal(5) ;}) =>* # nil | 'var1 |-> p:Real, 'var2 |-> toReal(5) #   such that p:Real > toReal(1) using QF_LRA .

smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; if ('var1 < q:Real) then {'var2 := toReal(5) ;}) =>* # nil | 'var1 |-> p:Real, 'var2 |-> toReal(5) #   such that p:Real > toReal(1) using QF_LRA .

smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; if ('var1 < q:Real) then {'var2 := q:Real ;}) =>* # nil | 'var1 |-> p:Real, 'var2 |-> q:Real #   such that p:Real > toReal(1) using QF_LRA .

*** Test conditional paths
smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; if ('var1 < q:Real) then {'var2 := q:Real ;}) =>* # nil | STR:Map{Var, Real} #   such that p:Real > toReal(1) using QF_LRA .
smt-search [2] in WHILE-MAUDE : start('var1 := p:Real ; if ('var1 < q:Real) then {'var2 := q:Real ;}) =>* # nil | STR:Map{Var, Real} #   such that p:Real > toReal(1) using QF_LRA .

*** Test then-path unfeasible (only solution: else branch)
smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; if ('var1 < p:Real) then {nil} else {'var2 := p:Real ;}) =>* # nil | STR:Map{Var, Real} #   such that p:Real > toReal(1) using QF_LRA .
*** No solution:
smt-search [2] in WHILE-MAUDE : start('var1 := p:Real ; if ('var1 < p:Real) then {nil} else {'var2 := p:Real ;}) =>* # nil | STR:Map{Var, Real} #   such that p:Real > toReal(1) using QF_LRA .


smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; 'var2 := toReal(1) ; while ('var2 < 'var1) do {'var2 := 'var2 + toReal(1) ; }) =>* # nil | STR:Map{Var, Real} #   such that p:Real > toReal(2) using QF_LRA .

smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; 'var2 := toReal(1) ; while ('var2 < 'var1) do {'var2 := 'var2 + toReal(1) ; }) =>* # nil | STR:Map{Var, Real} #   such that p:Real > toReal(2) using QF_LRA .



*** Factorial tests:

smt-search [1] in WHILE-MAUDE : start('n := p:Real ; 'res := toReal(1) ; while ('n >= toReal(1)) do {'res := 'res * 'n ; 'n := 'n - toReal(1) ; }) =>* # nil | ('res |-> toReal(120), STR:Map{Var, Real}) #   such that p:Real > toReal(0) using QF_LRA .

*** Test (not taking advantage of SE): can the factorial of 5 be negative?
smt-search [1] in WHILE-MAUDE : start('n := toReal(5) ; 'res := toReal(1) ; while ('n >= toReal(1)) do {'res := 'res * 'n ; 'n := 'n - toReal(1) ; }) =>* # nil | ('res |-> q:Real, STR:Map{Var, Real}) #   such that q:Real <= toReal(0) using QF_LRA .

*** Test (taking advantage of SE): can the factorial of any positive real n be negative?
- Does not terminate!!
smt-search [1] in WHILE-MAUDE : start('n := p:Real ; 'res := toReal(1) ; while ('n >= toReal(1)) do {'res := 'res * 'n ; 'n := 'n - toReal(1) ; }) =>* # nil | ('res |-> q:Real, STR:Map{Var, Real}) #   such that p:Real > toReal(0) and q:Real <= toReal(0) using QF_LRA .


*** Infinite loop
- Does not terminate:
smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; 'var2 := toReal(1) ; while (true) do {'var2 := 'var1 + toReal(1) ; }) =>* # nil | STR:Map{Var, Real} #   such that p:Real > toReal(2) using QF_LRA .

- Terminates with bounded search
smt-search [1, 10] in WHILE-MAUDE : start('var1 := p:Real ; 'var2 := toReal(1) ; while (true) do {'var2 := 'var1 + toReal(1) ; }) =>* # IL:List{Inst} | ('var2 |-> toReal(7), STR:Map{Var, Real}) #   such that p:Real > toReal(2) using QF_LRA .
smt-search [2, 20] in WHILE-MAUDE : start('var1 := p:Real ; 'var2 := toReal(1) ; while (true) do {'var2 := 'var2 + toReal(1) ; }) =>* # IL:List{Inst} | ('var2 |-> toReal(7), STR:Map{Var, Real}) #   such that p:Real > toReal(2) using QF_LRA .

- Terminates (reduces state space with folding):
{fold} smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; 'var2 := toReal(1) ; while (true) do {'var2 := 'var1 + toReal(1) ; }) =>* # nil | STR:Map{Var, Real} #   such that p:Real > toReal(2) using QF_LRA .
{fold} smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; 'var2 := toReal(1) ; while (true) do {'var2 := 'var2 + toReal(1) ; }) =>* # IL:List{Inst} | ('var2 |-> toReal(7), STR:Map{Var, Real}) #   such that p:Real > toReal(2) using QF_LRA .

***smt-search [1] in WHILE-MAUDE : start('var1 := p:Real ; if (lookup('var1) < q:Real) then {'var2 := toReal(5) ;}) =>* # nil | 'var1 |-> p:Real, 'var2 |-> toReal(5) #   such that p:Real > toReal(1) using QF_LRA .

***smt-search [1] start(var("var1") := p:Real ; if (var("var1") < q:Real) then {var("var2") := toReal(5) ;}) =>* # nil | var("var1") |-> p:Real, var("var2") |-> toReal(5) #   such that p:Real > toReal(1) using QF_LRA .
smt-search [1] downTerm(getTerm(metaReduce(upModule('WHILE-MAUDE, false), upTerm(start(var("var1") := p:Real ; if var("var1") < q:Real then{var("var2") := toReal(5) ;})))), err:State) =>* # nil | var("var1") |-> p:Real, var("var2") |-> toReal(5) #   such that p:Real > toReal(1) using QF_LRA .


********************
erew start('var1 := p:Real ; if ('var1 < q:Real) then {'var2 := toReal(5) ;}) .


red downTerm(getTerm(metaReduce(upModule('WHILE-MAUDE, false), upTerm(start(var("var1") := p:Real ; if (var("var1") < q:Real) then {var("var2") := toReal(5) ;})))), err:State) .

start('var1 := (p:Real + z:Real) ; if ('var1 < q:Real) then {'var2 := q:Real ;})

red metaSmtSearch(upModule('WHILE-MAUDE, false),
                    upTerm(getTerm(metaReduce(upModule('WHILE-MAUDE, false), upTerm(start('var1 := p:Real ; if ('var1 < q:Real) then {'var2 := toReal(5) ;}))))),
                    upTerm(# nil | 'var1 |-> p:Real, 'var2 |-> toReal(5) #),
                    upTerm(p:Real > toReal(1)) = upTerm((true).Boolean),
                    '* , unbounded, 1, 'QF_LRA) .

smt-search [1] in WHILE-MAUDE : downTerm(getTerm(metaReduce(upModule('WHILE-MAUDE, false), upTerm(start('var1 := p:Real ; if ('var1 < q:Real) then {'var2 := toReal(5) ;})))), errState) =>* # nil | STR:Map{Var, Real} #   such that p:Real > toReal(1) using QF_LRA .
smt-search [1] in WHILE-MAUDE : downTerm(getTerm(metaRewrite(upModule('WHILE-MAUDE, false), upTerm(start('var1 := p:Real ; if ('var1 < q:Real) then {'var2 := toReal(5) ;})), unbounded)), errState) =>* # nil | STR:Map{Var, Real} #   such that p:Real > toReal(1) using QF_LRA .




***crl [if..then] : 
***    # if BExp then { IL1 } else { IL2 } IL | STR #
***    =>
***    # IL1 IL | STR #
    ***if { 'true.Boolean , Type } := metaReduce(upModule('WHILE-LANG-AEXP-MOD, false), upTerm(eval(BExp, STR)))
    ***    .
***crl [if..else] : 
***    # if BExp then { IL1 } else { IL2 } IL | STR #
***    =>
***    # IL2 IL | STR #
    ***if { 'false.Boolean , Type } := metaReduce(upModule('WHILE-LANG-AEXP-MOD, false), upTerm(eval(BExp, STR)))
    ***    .