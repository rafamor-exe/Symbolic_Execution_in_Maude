load ../semantics-basics/semantics-basics-smtTypes.maude

fmod WHILE-LANG-INSTS-MOD is

    pr SMT-AEXP-MOD .

    sort Inst .

    op skip ; : -> Inst [ctor prec 20] .
    op _ := _ ; : Var AExp -> Inst [ctor prec 20] .

endfm

view Inst from TRIV to WHILE-LANG-INSTS-MOD is
  sort Elt to Inst .
endv

fmod WHILE-LANG-BLOCK-MOD is

    pr WHILE-LANG-INSTS-MOD .
    pr LIST{Inst} * (sort List{Inst} to Program) .

    op if _ then {_} else {_} : BExp Program Program -> Inst [ctor prec 20] .
    op if _ then {_} : BExp Program -> Inst [prec 20] .

    op while _ do {_} : BExp Program -> Inst [ctor prec 20] .

    var B : BExp .
    var IL1 : Program .

    eq if B then {IL1} = if B then {IL1} else {nil} .

endfm

fmod WHILE-LANG-SE-LOCS-MOD is
    pr QID .
    sort Location .
    ops skip assign if1 if2 while1 while2 while-inv assume : -> Location [ctor] .
    op loc : Qid -> Location [ctor] .
endfm

view Location from TRIV to WHILE-LANG-SE-LOCS-MOD is
  sort Elt to Location .
endv

fmod WHILE-SE-BASICS is
    pr WHILE-LANG-BLOCK-MOD .
    pr WHILE-LANG-SE-LOCS-MOD .
    pr LIST{Location} * (sort List{Location} to Path) .
endfm

fmod SMT-CONNECTION is
    pr REAL-INTEGER .

    sort AssignmentSMT .

    op _<--_ : Real Real -> AssignmentSMT [ctor] . *** test syntax
    op _<--_ : Integer Integer -> AssignmentSMT [ctor] . *** test syntax
    op _,_ : AssignmentSMT AssignmentSMT -> AssignmentSMT .
    op failed : -> AssignmentSMT [ctor] .

    op get-SMTassignment : Boolean -> AssignmentSMT [special (id-hook SpecialHubSymbol)] .

endfm

mod WHILE-MAUDE is

    pr WHILE-SE-BASICS .
    pr LIST{Location} * (sort List{Location} to Path) .
    ***pr META-LEVEL * (op _=_ to _=M_) * (op _+_ to _+M_) .
    pr SMT-CONNECTION .
    protecting LIST{PairVarValue} .

    sorts SEState PState ConcolicState ConcolicStateCore .
    sort ConstrainedStart .
    
    op < _ | _ > : Program Map{Var, Value} -> PState [ctor] . 
    op errState : -> PState [ctor] .

    op _ {_} < {_} : PState Boolean Path -> SEState [ctor] . 

    op _ where _ : Program Boolean -> ConstrainedStart [ctor] .

    
    op [_] [_] [_] : PState SEState Int -> ConcolicStateCore [ctor] .
    op _ [_] : ConcolicStateCore Map{Var, Value} -> ConcolicState [ctor] .

    vars Var Var1 Var2 : Var .
    vars B C1 Constraints Constraints' Constraint : Boolean .
    vars BExp BExp2 : BExp .
    vars R Rconc : Real .
    vars I Iconc : Integer .
    vars P IL IL1 IL2 : Program .
    vars STR STR' SymbSTR STRInit : Map{Var, Value} .
    var AExp : AExp .
    var Path : Path .
    var SVDeclL : Program .
    var V : Value .
    vars SEPState CEPState : PState .
    var N : Int .
    var NzN : NzNat .
    var AssignmentSMT : AssignmentSMT .

    op start : Program -> ConcolicState .
    op start : ConstrainedStart -> ConcolicState .
    eq start(P) = $start(P, nil, empty, true) .
    eq start(P where B) = $start(P, nil, empty, B) .
    op start : Program Program -> ConcolicState .
    op start : ConstrainedStart Program -> ConcolicState .
    eq start(P, SVDeclL) = $start(P, SVDeclL, empty, true) .
    eq start(P where B, SVDeclL) = $start(P, SVDeclL, empty, B) .
    op $start : Program Program Map{Var, Value} Boolean -> ConcolicState .
    eq $start(P, nil, STR, B) = [ < P | init-CStore(STR, B) > ] [ < P | STR > {B} < {nil} ] [size(B)] [STR] . *** Don't negate initial conditions, only path conditions
    eq $start(P, (Var := V ;) SVDeclL, STR, B) = $start(P, SVDeclL, insert(Var, V, STR), B) .

    rl [C-skip] : 
        [ < skip ; IL | STR > ] [ SEPState {Constraints} < {Path} ] [N]
        =>
        [ < IL | STR > ] [ SEPState {Constraints} < {Path} ] [N] .

    rl [C-assign] : 
        [ < Var := AExp ; IL | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N]
        =>
        [ < IL | insert(Var, eval(AExp, STR), STR) > ] [ < P | insert(Var, eval(AExp, SymbSTR), SymbSTR) > {Constraints} < {Path} ] [N] .
    
    ***rl [assign-boolean] : 
    ***    < Var := B ; IL | STR >
    ***    =>
    ***    < IL | insert(Var, {type boolean, val val(B)}, STR) > .
    ***
    ***crl [assign-var] : 
    ***    < Var := Var1 ; IL | STR >
    ***    =>
    ***    < IL | insert(Var, {type getType(VarState), val getVal(VarState)}, STR) >
    ***    if VarState := STR[Var1] .

    crl [C-if..then] :
        [ < if BExp then { IL1 } else { IL2 } IL | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N]
        =>
        [ < IL1 IL | STR > ] [ < P | SymbSTR > {Constraints'} < {Path} ] [N]
        if Constraints' := (Constraints and eval(BExp, SymbSTR))
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) === (true).Boolean)) .

    crl [C-if..else] :
        [ < if BExp then { IL1 } else { IL2 } IL | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N]
        =>
        [ < IL2 IL | STR > ] [ < P | SymbSTR > {Constraints'} < {Path} ] [N]
        if Constraints' := (Constraints and (not eval(BExp, SymbSTR))) 
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) =/== (true).Boolean)) .
    

    crl [C-while..loop] : 
        [ < while BExp do { IL1 } IL | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N]
        =>
        [ < IL1 while BExp do { IL1 } IL | STR > ] [ < P | SymbSTR > {Constraints'} < {Path} ] [N]
        if Constraints' := (Constraints and eval(BExp, SymbSTR)) 
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) === (true).Boolean)) .
        
    crl [C-while..exit] : 
        [ < while BExp do { IL1 } IL | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N]
        =>
        [ < IL | STR > ] [ < P | SymbSTR > {Constraints'} < {Path} ] [N]
        if Constraints' := (Constraints and (not eval(BExp, SymbSTR)))
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(eval(BExp, STR) =/== (true).Boolean)) .
    
    crl [reinit-Cexec-negInOrder] : 
        [ < nil | STR > ] [ < P | SymbSTR > {Constraints} < {Path} ] [N] [STRInit]
        =>
        [ < P | init-CStore(STRInit, Constraints') > ] [ < P | STRInit > {Constraints'} < {Path} ] [N + 1] [STRInit]
        if N < size(Constraints)
        /\ Constraints' := trunc-nth(negate-nth(Constraints, N), N)
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(Constraints')) . 
    
    crl [reinit-Cexec-negLast] : 
        [ < nil | STR > ] [ < P | SymbSTR > {Constraints and C1} < {Path} ] [N] [STRInit]
        =>
        [ < P | init-CStore(STRInit, Constraints') > ] [ < P | STRInit > {Constraints'} < {Path} ] [N + 1] [STRInit]
        if N < size(Constraints and C1)
        /\ Constraints' := Constraints and (not C1)
        /\ metaCheck(upModule('WHILE-MAUDE, false), upTerm(Constraints')) .
    
    op negate-nth : Boolean Nat -> Boolean .
    eq negate-nth(C1 and Constraints, 0) = (not C1) and Constraints .
    eq negate-nth(C1, 0) = not C1 .
    ceq negate-nth(C1 and Constraints, NzN) = C1 and negate-nth(Constraints, NzN - 1)
        if NzN < size(C1 and Constraints) . *** TODO: Multiple parses due to C1 being able to be _and_ too
    eq negate-nth(C1, NzN) = true [owise] . 
    
    op trunc-nth : Boolean Nat -> Boolean .
    eq trunc-nth((C1 and Constraints), 0) = C1 .
    eq trunc-nth(C1, 0) = C1 [owise] .
    ceq trunc-nth((C1 and Constraints), NzN) = C1 and trunc-nth(Constraints, NzN - 1)
        if NzN < size((C1 and Constraints)) .
    eq trunc-nth(C1, NzN) = true [owise] .

    op init-CStore : Map{Var, Value} Boolean -> Map{Var, Value} .
    eq init-CStore(STR, Constraints) = $apply-SMTassignment(STR, get-SMTassignment(Constraints)) .

    op $apply-SMTassignment : Map{Var, Value} AssignmentSMT -> Map{Var, Value} .
    eq $apply-SMTassignment((Var |-> val(R), STR), R <-- Rconc) = (Var |-> val(Rconc), STR) .
    eq $apply-SMTassignment((Var |-> val(R), STR), R <-- Rconc , AssignmentSMT) = (Var |-> val(Rconc), $apply-SMTassignment(STR, AssignmentSMT)) .
    eq $apply-SMTassignment((Var |-> val(I), STR), I <-- Iconc) = (Var |-> val(Iconc), STR) .
    eq $apply-SMTassignment((Var |-> val(I), STR), I <-- Iconc , AssignmentSMT) = (Var |-> val(Iconc), $apply-SMTassignment(STR, AssignmentSMT)) .
    eq $apply-SMTassignment(STR, failed) = STR .

    op size : Boolean -> Nat .
    eq size((C1 and Constraints)) = 1 + size(Constraints) .
    eq size(C1) = 1 .

endm